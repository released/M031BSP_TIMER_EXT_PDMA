; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c_master.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c_master.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\Kalman_Filter -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\i2c_master.crf ..\i2c_master.c]
                          THUMB

                          AREA ||i.I2C0_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C0_IRQHandler PROC
;;;29     
;;;30     void I2Cx_Master_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;31     {
;;;32         uint32_t u32Status;
;;;33     
;;;34         u32Status = I2C_GET_STATUS(MASTER_I2C);
000002  4908              LDR      r1,|L1.36|
000004  68c8              LDR      r0,[r1,#0xc]
;;;35     
;;;36         if (I2C_GET_TIMEOUT_FLAG(MASTER_I2C))
000006  694a              LDR      r2,[r1,#0x14]
000008  43d2              MVNS     r2,r2
00000a  07d2              LSLS     r2,r2,#31
00000c  d006              BEQ      |L1.28|
;;;37         {
;;;38             /* Clear I2C Timeout Flag */
;;;39             I2C_ClearTimeoutFlag(MASTER_I2C);                   
;;;40         }    
;;;41         else
;;;42         {
;;;43             if (I2Cx_Master_HandlerFn != NULL)
00000e  4906              LDR      r1,|L1.40|
000010  688a              LDR      r2,[r1,#8]  ; I2Cx_Master_HandlerFn
000012  2a00              CMP      r2,#0
000014  d001              BEQ      |L1.26|
;;;44                 I2Cx_Master_HandlerFn(u32Status);
000016  6889              LDR      r1,[r1,#8]  ; I2Cx_Master_HandlerFn
000018  4788              BLX      r1
                  |L1.26|
;;;45         }
;;;46     }
00001a  bd10              POP      {r4,pc}
                  |L1.28|
00001c  4608              MOV      r0,r1                 ;39
00001e  f7fffffe          BL       I2C_ClearTimeoutFlag
000022  bd10              POP      {r4,pc}
;;;47     
                          ENDP

                  |L1.36|
                          DCD      0x40080000
                  |L1.40|
                          DCD      ||.data||

                          AREA ||i.I2Cx_MasterRx_multi||, CODE, READONLY, ALIGN=2

                  I2Cx_MasterRx_multi PROC
;;;47     
;;;48     void I2Cx_MasterRx_multi(uint32_t u32Status)
000000  b5f8              PUSH     {r3-r7,lr}
;;;49     {
;;;50         if(u32Status == MASTER_START_TRANSMIT) //0x08                       	/* START has been transmitted and prepare SLA+W */
;;;51         {
;;;52             I2C_SET_DATA(MASTER_I2C, ((g_u8DeviceAddr_m << 1) | I2C_WR));    				/* Write SLA+W to Register I2CDAT */
;;;53             I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
000002  243c              MOVS     r4,#0x3c
000004  4e2a              LDR      r6,|L2.176|
000006  4d2b              LDR      r5,|L2.180|
000008  2808              CMP      r0,#8                 ;50
00000a  d019              BEQ      |L2.64|
;;;54     
;;;55     		I2Cx_Master_LOG(u32Status);
;;;56         }
;;;57         else if(u32Status == MASTER_TRANSMIT_ADDRESS_ACK) //0x18        			/* SLA+W has been transmitted and ACK has been received */
00000c  2818              CMP      r0,#0x18
00000e  d01a              BEQ      |L2.70|
;;;58         {
;;;59             I2C_SET_DATA(MASTER_I2C, g_au8Reg);
;;;60             I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;61     		
;;;62     		I2Cx_Master_LOG(u32Status);
;;;63         }
;;;64         else if(u32Status == MASTER_TRANSMIT_ADDRESS_NACK) //0x20            	/* SLA+W has been transmitted and NACK has been received */
000010  2820              CMP      r0,#0x20
000012  d01d              BEQ      |L2.80|
;;;65         {
;;;66             I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA | I2C_CTL_STO);
;;;67     
;;;68     //        I2C_STOP(MASTER_I2C);
;;;69     //        I2C_START(MASTER_I2C);
;;;70     		
;;;71     		I2Cx_Master_LOG(u32Status);
;;;72         }
;;;73         else if(u32Status == MASTER_TRANSMIT_DATA_ACK) //0x28                  	/* DATA has been transmitted and ACK has been received */
;;;74         {
;;;75             if (rawlenth > 0)
;;;76     			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA);				//repeat start
;;;77     		else
;;;78     		{
;;;79     			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;80     			g_u8EndFlag = 1;
000014  2701              MOVS     r7,#1
000016  2828              CMP      r0,#0x28              ;73
000018  d01e              BEQ      |L2.88|
;;;81     		}
;;;82     		
;;;83     		I2Cx_Master_LOG(u32Status);
;;;84         }
;;;85         else if(u32Status == MASTER_REPEAT_START) //0x10                  		/* Repeat START has been transmitted and prepare SLA+R */
00001a  2810              CMP      r0,#0x10
00001c  d029              BEQ      |L2.114|
;;;86         {
;;;87             I2C_SET_DATA(MASTER_I2C, ((g_u8DeviceAddr_m << 1) | I2C_RD));   		/* Write SLA+R to Register I2CDAT */
;;;88             I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;89     		
;;;90     		I2Cx_Master_LOG(u32Status);
;;;91         }
;;;92         else if(u32Status == MASTER_RECEIVE_ADDRESS_ACK) //0x40                	/* SLA+R has been transmitted and ACK has been received */
00001e  2840              CMP      r0,#0x40
000020  d02b              BEQ      |L2.122|
;;;93         {
;;;94     		if (rawlenth > 1)
;;;95     			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;96     		else
;;;97     			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;98     
;;;99     		I2Cx_Master_LOG(u32Status);
;;;100        }
;;;101    	else if(u32Status == MASTER_RECEIVE_DATA_ACK) //0x50                 	/* DATA has been received and ACK has been returned */
000022  2850              CMP      r0,#0x50
000024  d02d              BEQ      |L2.130|
;;;102        {
;;;103            g_au8Buffer[g_u8DataLen_m++] = (unsigned char) I2C_GetData(MASTER_I2C);
;;;104            if (g_u8DataLen_m < (rawlenth-1))
;;;105    		{
;;;106    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;107    		}
;;;108    		else
;;;109    		{
;;;110    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;111    		}
;;;112    		
;;;113    		I2Cx_Master_LOG(u32Status);
;;;114        }
;;;115        else if(u32Status == MASTER_RECEIVE_DATA_NACK) //0x58                  	/* DATA has been received and NACK has been returned */
000026  2858              CMP      r0,#0x58
000028  d111              BNE      |L2.78|
;;;116        {
;;;117            g_au8Buffer[g_u8DataLen_m++] = (unsigned char) I2C_GetData(MASTER_I2C);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       I2C_GetData
000030  4601              MOV      r1,r0
000032  78b0              LDRB     r0,[r6,#2]  ; g_u8DataLen_m
000034  68f2              LDR      r2,[r6,#0xc]  ; g_au8Buffer
000036  1812              ADDS     r2,r2,r0
000038  1c40              ADDS     r0,r0,#1
00003a  70b0              STRB     r0,[r6,#2]
00003c  7011              STRB     r1,[r2,#0]
;;;118            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;119            g_u8EndFlag = 1;
;;;120    
;;;121    		
;;;122    		I2Cx_Master_LOG(u32Status);
00003e  e012              B        |L2.102|
                  |L2.64|
000040  7870              LDRB     r0,[r6,#1]            ;52  ; g_u8DeviceAddr_m
000042  0040              LSLS     r0,r0,#1              ;52
000044  e000              B        |L2.72|
                  |L2.70|
000046  7930              LDRB     r0,[r6,#4]            ;59  ; g_au8Reg
                  |L2.72|
000048  60a8              STR      r0,[r5,#8]            ;52
00004a  e02d              B        |L2.168|
                  |L2.76|
00004c  6028              STR      r0,[r5,#0]            ;53
                  |L2.78|
;;;123        }
;;;124        else
;;;125        {
;;;126    		#if defined (DEBUG_LOG_MASTER_LV1)
;;;127            /* TO DO */
;;;128            printf("I2Cx_MasterRx_multi Status 0x%x is NOT processed\n", u32Status);
;;;129    		#endif
;;;130        }
;;;131    }
00004e  bdf8              POP      {r3-r7,pc}
                  |L2.80|
000050  6828              LDR      r0,[r5,#0]            ;66
000052  43a0              BICS     r0,r0,r4              ;66
000054  3038              ADDS     r0,r0,#0x38           ;66
000056  e7f9              B        |L2.76|
                  |L2.88|
000058  78f0              LDRB     r0,[r6,#3]            ;75  ; rawlenth
00005a  2800              CMP      r0,#0                 ;75
00005c  d003              BEQ      |L2.102|
00005e  6828              LDR      r0,[r5,#0]            ;76
000060  43a0              BICS     r0,r0,r4              ;76
000062  3028              ADDS     r0,r0,#0x28           ;76
000064  e7f2              B        |L2.76|
                  |L2.102|
000066  6828              LDR      r0,[r5,#0]            ;79
000068  43a0              BICS     r0,r0,r4              ;79
00006a  3018              ADDS     r0,r0,#0x18           ;79
00006c  6028              STR      r0,[r5,#0]            ;79
00006e  7037              STRB     r7,[r6,#0]            ;80
000070  bdf8              POP      {r3-r7,pc}
                  |L2.114|
000072  7870              LDRB     r0,[r6,#1]            ;87  ; g_u8DeviceAddr_m
000074  0040              LSLS     r0,r0,#1              ;87
000076  1c40              ADDS     r0,r0,#1              ;87
000078  e7e6              B        |L2.72|
                  |L2.122|
00007a  78f0              LDRB     r0,[r6,#3]            ;94  ; rawlenth
00007c  2801              CMP      r0,#1                 ;94
00007e  d80f              BHI      |L2.160|
000080  e012              B        |L2.168|
                  |L2.130|
000082  4628              MOV      r0,r5                 ;103
000084  f7fffffe          BL       I2C_GetData
000088  4601              MOV      r1,r0                 ;103
00008a  78b0              LDRB     r0,[r6,#2]            ;103  ; g_u8DataLen_m
00008c  68f2              LDR      r2,[r6,#0xc]          ;103  ; g_au8Buffer
00008e  1812              ADDS     r2,r2,r0              ;103
000090  1c40              ADDS     r0,r0,#1              ;103
000092  70b0              STRB     r0,[r6,#2]            ;103
000094  7011              STRB     r1,[r2,#0]            ;103
000096  78b1              LDRB     r1,[r6,#2]            ;104  ; g_u8DataLen_m
000098  78f0              LDRB     r0,[r6,#3]            ;104  ; rawlenth
00009a  1e40              SUBS     r0,r0,#1              ;104
00009c  4281              CMP      r1,r0                 ;104
00009e  da03              BGE      |L2.168|
                  |L2.160|
0000a0  6828              LDR      r0,[r5,#0]            ;106
0000a2  43a0              BICS     r0,r0,r4              ;106
0000a4  300c              ADDS     r0,r0,#0xc            ;106
0000a6  e7d1              B        |L2.76|
                  |L2.168|
0000a8  6828              LDR      r0,[r5,#0]            ;110
0000aa  43a0              BICS     r0,r0,r4              ;110
0000ac  3008              ADDS     r0,r0,#8              ;110
0000ae  e7cd              B        |L2.76|
;;;132    
                          ENDP

                  |L2.176|
                          DCD      ||.data||
                  |L2.180|
                          DCD      0x40080000

                          AREA ||i.I2Cx_MasterTx_multi||, CODE, READONLY, ALIGN=2

                  I2Cx_MasterTx_multi PROC
;;;132    
;;;133    void I2Cx_MasterTx_multi(uint32_t u32Status)
000000  b510              PUSH     {r4,lr}
;;;134    {
;;;135        if(u32Status == MASTER_START_TRANSMIT)  //0x08                     	/* START has been transmitted */
;;;136        {
;;;137            I2C_SET_DATA(MASTER_I2C, ((g_u8DeviceAddr_m << 1) | I2C_WR));    			/* Write SLA+W to Register I2CDAT */
000002  491d              LDR      r1,|L3.120|
;;;138            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
000004  223c              MOVS     r2,#0x3c
000006  4b1d              LDR      r3,|L3.124|
000008  2808              CMP      r0,#8                 ;135
00000a  d011              BEQ      |L3.48|
;;;139    
;;;140    		I2Cx_Master_LOG(u32Status);
;;;141    		
;;;142        }
;;;143        else if(u32Status == MASTER_TRANSMIT_ADDRESS_ACK)  //0x18           	/* SLA+W has been transmitted and ACK has been received */
00000c  2818              CMP      r0,#0x18
00000e  d012              BEQ      |L3.54|
;;;144        {
;;;145            I2C_SET_DATA(MASTER_I2C, g_au8Reg);
;;;146            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;147    		
;;;148    		I2Cx_Master_LOG(u32Status);	
;;;149        }
;;;150        else if(u32Status == MASTER_TRANSMIT_ADDRESS_NACK) //0x20           /* SLA+W has been transmitted and NACK has been received */
000010  2820              CMP      r0,#0x20
000012  d017              BEQ      |L3.68|
;;;151        {
;;;152            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA | I2C_CTL_STO);
;;;153    
;;;154    //        I2C_STOP(MASTER_I2C);
;;;155    //        I2C_START(MASTER_I2C);
;;;156    
;;;157    		I2Cx_Master_LOG(u32Status);	
;;;158        }
;;;159        else if(u32Status == MASTER_TRANSMIT_DATA_ACK) //0x28              	/* DATA has been transmitted and ACK has been received */
000014  2828              CMP      r0,#0x28
000016  d019              BEQ      |L3.76|
;;;160        {
;;;161            if(g_u8DataLen_m < rawlenth)
;;;162            {
;;;163                I2C_SET_DATA(MASTER_I2C, g_au8Buffer[g_u8DataLen_m++]);
;;;164                I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;165            }
;;;166            else
;;;167            {
;;;168                I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;169                g_u8EndFlag = 1;
;;;170            }
;;;171    
;;;172    		I2Cx_Master_LOG(u32Status);		
;;;173        }
;;;174        else if(u32Status == MASTER_ARBITRATION_LOST) //0x38
000018  2838              CMP      r0,#0x38
00001a  d029              BEQ      |L3.112|
;;;175        {
;;;176    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA_SI_AA);
;;;177    
;;;178    		I2Cx_Master_LOG(u32Status);		
;;;179        }
;;;180        else if(u32Status == BUS_ERROR) //0x00
00001c  2800              CMP      r0,#0
00001e  d110              BNE      |L3.66|
;;;181        {
;;;182    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STO_SI_AA);
000020  6808              LDR      r0,[r1,#0]
000022  4390              BICS     r0,r0,r2
000024  301c              ADDS     r0,r0,#0x1c
000026  6008              STR      r0,[r1,#0]
;;;183    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI_AA);
000028  6808              LDR      r0,[r1,#0]
00002a  4390              BICS     r0,r0,r2
00002c  300c              ADDS     r0,r0,#0xc
;;;184    		
;;;185    		I2Cx_Master_LOG(u32Status);		
00002e  e007              B        |L3.64|
                  |L3.48|
000030  7858              LDRB     r0,[r3,#1]            ;137  ; g_u8DeviceAddr_m
000032  0040              LSLS     r0,r0,#1              ;137
000034  e000              B        |L3.56|
                  |L3.54|
000036  7918              LDRB     r0,[r3,#4]            ;145  ; g_au8Reg
                  |L3.56|
000038  6088              STR      r0,[r1,#8]            ;137
00003a  6808              LDR      r0,[r1,#0]            ;138
00003c  4390              BICS     r0,r0,r2              ;138
00003e  3008              ADDS     r0,r0,#8              ;138
                  |L3.64|
000040  6008              STR      r0,[r1,#0]            ;138
                  |L3.66|
;;;186        }		
;;;187        else
;;;188        {
;;;189    		#if defined (DEBUG_LOG_MASTER_LV1)
;;;190            /* TO DO */
;;;191            printf("I2Cx_MasterTx_multi Status 0x%x is NOT processed\n", u32Status);
;;;192    		#endif
;;;193        }
;;;194    }
000042  bd10              POP      {r4,pc}
                  |L3.68|
000044  6808              LDR      r0,[r1,#0]            ;152
000046  4390              BICS     r0,r0,r2              ;152
000048  3038              ADDS     r0,r0,#0x38           ;152
00004a  e7f9              B        |L3.64|
                  |L3.76|
00004c  7898              LDRB     r0,[r3,#2]            ;161  ; g_u8DataLen_m
00004e  78dc              LDRB     r4,[r3,#3]            ;161  ; rawlenth
000050  42a0              CMP      r0,r4                 ;161
000052  d206              BCS      |L3.98|
000054  7898              LDRB     r0,[r3,#2]            ;163  ; g_u8DataLen_m
000056  68dc              LDR      r4,[r3,#0xc]          ;163  ; g_au8Buffer
000058  1824              ADDS     r4,r4,r0              ;163
00005a  1c40              ADDS     r0,r0,#1              ;163
00005c  7098              STRB     r0,[r3,#2]            ;163
00005e  7820              LDRB     r0,[r4,#0]            ;163
000060  e7ea              B        |L3.56|
                  |L3.98|
000062  6808              LDR      r0,[r1,#0]            ;168
000064  4390              BICS     r0,r0,r2              ;168
000066  3018              ADDS     r0,r0,#0x18           ;168
000068  6008              STR      r0,[r1,#0]            ;168
00006a  2001              MOVS     r0,#1                 ;169
00006c  7018              STRB     r0,[r3,#0]            ;169
00006e  bd10              POP      {r4,pc}
                  |L3.112|
000070  6808              LDR      r0,[r1,#0]            ;176
000072  4390              BICS     r0,r0,r2              ;176
000074  302c              ADDS     r0,r0,#0x2c           ;176
000076  e7e3              B        |L3.64|
;;;195    
                          ENDP

                  |L3.120|
                          DCD      0x40080000
                  |L3.124|
                          DCD      ||.data||

                          AREA ||i.I2Cx_Master_LOG||, CODE, READONLY, ALIGN=1

                  I2Cx_Master_LOG PROC
;;;22     
;;;23     void I2Cx_Master_LOG(uint32_t u32Status)
000000  4770              BX       lr
;;;24     {
;;;25     	#if defined (DEBUG_LOG_MASTER_LV1)
;;;26         printf("%s  : 0x%2x \r\n", __FUNCTION__ , u32Status);
;;;27     	#endif
;;;28     }
;;;29     
                          ENDP


                          AREA ||i.I2Cx_ReadMultiFromSlaveIRQ||, CODE, READONLY, ALIGN=2

                  I2Cx_ReadMultiFromSlaveIRQ PROC
;;;218    
;;;219    void I2Cx_ReadMultiFromSlaveIRQ(uint8_t address,uint8_t reg,uint8_t *data,uint16_t len)
000000  b510              PUSH     {r4,lr}
;;;220    { 
;;;221    	g_u8DeviceAddr_m = address;
000002  4c0a              LDR      r4,|L5.44|
000004  7060              STRB     r0,[r4,#1]
;;;222    	rawlenth = len;
000006  70e3              STRB     r3,[r4,#3]
;;;223    	g_au8Reg = reg ;
000008  7121              STRB     r1,[r4,#4]
;;;224    	g_au8Buffer = data;
;;;225    
;;;226    	g_u8EndFlag = 0;
00000a  2000              MOVS     r0,#0
00000c  60e2              STR      r2,[r4,#0xc]  ; g_au8Buffer
00000e  7020              STRB     r0,[r4,#0]
;;;227    	g_u8DataLen_m = 0;
000010  70a0              STRB     r0,[r4,#2]
;;;228    
;;;229    	/* I2C function to read data from slave */
;;;230    	I2Cx_Master_HandlerFn = (I2C_FUNC)I2Cx_MasterRx_multi;
000012  4807              LDR      r0,|L5.48|
000014  60a0              STR      r0,[r4,#8]  ; I2Cx_Master_HandlerFn
;;;231    
;;;232    //	printf("I2Cx_MasterRx_multi finish\r\n");
;;;233    	
;;;234    	I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA);
000016  4907              LDR      r1,|L5.52|
000018  6808              LDR      r0,[r1,#0]
00001a  223c              MOVS     r2,#0x3c
00001c  4390              BICS     r0,r0,r2
00001e  3020              ADDS     r0,r0,#0x20
000020  6008              STR      r0,[r1,#0]
                  |L5.34|
;;;235    
;;;236    	/* Wait I2C Rx Finish */
;;;237    	while(g_u8EndFlag == 0);
000022  7820              LDRB     r0,[r4,#0]  ; g_u8EndFlag
000024  2800              CMP      r0,#0
000026  d0fc              BEQ      |L5.34|
;;;238    	
;;;239    }
000028  bd10              POP      {r4,pc}
;;;240    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      ||.data||
                  |L5.48|
                          DCD      I2Cx_MasterRx_multi
                  |L5.52|
                          DCD      0x40080000

                          AREA ||i.I2Cx_ReadSingleToSlaveIRQ||, CODE, READONLY, ALIGN=2

                  I2Cx_ReadSingleToSlaveIRQ PROC
;;;267    /*---------------------------------------------------------------------------------------------------------*/
;;;268    void I2Cx_ReadSingleToSlaveIRQ(uint8_t address, uint8_t reg,uint8_t *data)
000000  4b0a              LDR      r3,|L6.44|
;;;269    {
;;;270    	g_u8DeviceAddr_m = address;
000002  7058              STRB     r0,[r3,#1]
;;;271    	rawlenth = 1;
000004  2001              MOVS     r0,#1
000006  70d8              STRB     r0,[r3,#3]
;;;272    	g_au8Reg = reg ;
000008  7119              STRB     r1,[r3,#4]
;;;273    	g_au8Buffer = data;
;;;274    
;;;275    	g_u8DataLen_m = 0;
00000a  2000              MOVS     r0,#0
00000c  60da              STR      r2,[r3,#0xc]  ; g_au8Buffer
00000e  7098              STRB     r0,[r3,#2]
;;;276    	g_u8EndFlag = 0;
000010  7018              STRB     r0,[r3,#0]
;;;277    	
;;;278    	/* I2C function to write data to slave */
;;;279    	I2Cx_Master_HandlerFn = (I2C_FUNC)I2Cx_MasterRx_multi;
000012  4807              LDR      r0,|L6.48|
000014  6098              STR      r0,[r3,#8]  ; I2Cx_Master_HandlerFn
;;;280    	
;;;281    	/* I2C as master sends START signal */
;;;282    	I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA);
000016  4907              LDR      r1,|L6.52|
000018  6808              LDR      r0,[r1,#0]
00001a  223c              MOVS     r2,#0x3c
00001c  4390              BICS     r0,r0,r2
00001e  3020              ADDS     r0,r0,#0x20
000020  6008              STR      r0,[r1,#0]
                  |L6.34|
;;;283    
;;;284    	/* Wait I2C Tx Finish */
;;;285    	while (g_u8EndFlag == 0);	
000022  7818              LDRB     r0,[r3,#0]  ; g_u8EndFlag
000024  2800              CMP      r0,#0
000026  d0fc              BEQ      |L6.34|
;;;286    }
000028  4770              BX       lr
;;;287    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      ||.data||
                  |L6.48|
                          DCD      I2Cx_MasterRx_multi
                  |L6.52|
                          DCD      0x40080000

                          AREA ||i.I2Cx_WriteMultiToSlaveIRQ||, CODE, READONLY, ALIGN=2

                  I2Cx_WriteMultiToSlaveIRQ PROC
;;;195    
;;;196    void I2Cx_WriteMultiToSlaveIRQ(uint8_t address,uint8_t reg,uint8_t *data,uint16_t len)
000000  b510              PUSH     {r4,lr}
;;;197    {		
;;;198    	g_u8DeviceAddr_m = address;
000002  4c0a              LDR      r4,|L7.44|
000004  7060              STRB     r0,[r4,#1]
;;;199    	rawlenth = len;
000006  70e3              STRB     r3,[r4,#3]
;;;200    	g_au8Reg = reg;
000008  7121              STRB     r1,[r4,#4]
;;;201    	g_au8Buffer = data;
;;;202    
;;;203    	g_u8DataLen_m = 0;
00000a  2100              MOVS     r1,#0
00000c  60e2              STR      r2,[r4,#0xc]  ; g_au8Buffer
00000e  70a1              STRB     r1,[r4,#2]
;;;204    	g_u8EndFlag = 0;
000010  7021              STRB     r1,[r4,#0]
;;;205    
;;;206    	/* I2C function to write data to slave */
;;;207    	I2Cx_Master_HandlerFn = (I2C_FUNC)I2Cx_MasterTx_multi;
000012  4807              LDR      r0,|L7.48|
000014  60a0              STR      r0,[r4,#8]  ; I2Cx_Master_HandlerFn
;;;208    
;;;209    //	printf("I2Cx_MasterTx_multi finish\r\n");
;;;210    
;;;211    	/* I2C as master sends START signal */
;;;212    	I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA);
000016  4807              LDR      r0,|L7.52|
000018  6802              LDR      r2,[r0,#0]
00001a  233c              MOVS     r3,#0x3c
00001c  439a              BICS     r2,r2,r3
00001e  3220              ADDS     r2,r2,#0x20
000020  6002              STR      r2,[r0,#0]
                  |L7.34|
;;;213    
;;;214    	/* Wait I2C Tx Finish */
;;;215    	while(g_u8EndFlag == 0);
000022  7820              LDRB     r0,[r4,#0]  ; g_u8EndFlag
000024  2800              CMP      r0,#0
000026  d0fc              BEQ      |L7.34|
;;;216    	g_u8EndFlag = 0;
000028  7021              STRB     r1,[r4,#0]
;;;217    }
00002a  bd10              POP      {r4,pc}
;;;218    
                          ENDP

                  |L7.44|
                          DCD      ||.data||
                  |L7.48|
                          DCD      I2Cx_MasterTx_multi
                  |L7.52|
                          DCD      0x40080000

                          AREA ||i.I2Cx_WriteSingleToSlaveIRQ||, CODE, READONLY, ALIGN=2

                  I2Cx_WriteSingleToSlaveIRQ PROC
;;;244    /*---------------------------------------------------------------------------------------------------------*/
;;;245    void I2Cx_WriteSingleToSlaveIRQ(uint8_t address,uint8_t reg, uint8_t *data)
000000  4b0a              LDR      r3,|L8.44|
;;;246    {
;;;247    	g_u8DeviceAddr_m = address;
000002  7058              STRB     r0,[r3,#1]
;;;248    	rawlenth = 1;
000004  2001              MOVS     r0,#1
000006  70d8              STRB     r0,[r3,#3]
;;;249    	g_au8Reg = reg;
000008  7119              STRB     r1,[r3,#4]
;;;250    	g_au8Buffer = data;
;;;251    
;;;252    	g_u8DataLen_m = 0;
00000a  2000              MOVS     r0,#0
00000c  60da              STR      r2,[r3,#0xc]  ; g_au8Buffer
00000e  7098              STRB     r0,[r3,#2]
;;;253    	g_u8EndFlag = 0;
000010  7018              STRB     r0,[r3,#0]
;;;254    	
;;;255    	/* I2C function to write data to slave */
;;;256    	I2Cx_Master_HandlerFn = (I2C_FUNC)I2Cx_MasterTx_multi;
000012  4807              LDR      r0,|L8.48|
000014  6098              STR      r0,[r3,#8]  ; I2Cx_Master_HandlerFn
;;;257    	
;;;258    	/* I2C as master sends START signal */
;;;259    	I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA);
000016  4907              LDR      r1,|L8.52|
000018  6808              LDR      r0,[r1,#0]
00001a  223c              MOVS     r2,#0x3c
00001c  4390              BICS     r0,r0,r2
00001e  3020              ADDS     r0,r0,#0x20
000020  6008              STR      r0,[r1,#0]
                  |L8.34|
;;;260    
;;;261    	/* Wait I2C Tx Finish */
;;;262    	while (g_u8EndFlag == 0);	
000022  7818              LDRB     r0,[r3,#0]  ; g_u8EndFlag
000024  2800              CMP      r0,#0
000026  d0fc              BEQ      |L8.34|
;;;263    }
000028  4770              BX       lr
;;;264    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      ||.data||
                  |L8.48|
                          DCD      I2Cx_MasterTx_multi
                  |L8.52|
                          DCD      0x40080000

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8EndFlag
000000  00                DCB      0x00
                  g_u8DeviceAddr_m
000001  00                DCB      0x00
                  g_u8DataLen_m
000002  00                DCB      0x00
                  rawlenth
000003  00                DCB      0x00
                  g_au8Reg
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  I2Cx_Master_HandlerFn
                          DCD      0x00000000
                  g_au8Buffer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\i2c_master.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_i2c_master_c_ae965f01____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_i2c_master_c_ae965f01____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_i2c_master_c_ae965f01____REVSH|
#line 402
|__asm___12_i2c_master_c_ae965f01____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
