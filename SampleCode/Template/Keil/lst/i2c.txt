; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\Kalman_Filter -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\i2c.crf ..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;97       */
;;;98     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;99     {
;;;100        i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;101    }
000008  4770              BX       lr
;;;102    
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;69     
;;;70     void I2C_Close(I2C_T *i2c)
000000  4a0a              LDR      r2,|L2.44|
;;;71     {
;;;72         /* Reset I2C Controller */
;;;73         if (i2c == I2C0)
;;;74         {
;;;75             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  02d1              LSLS     r1,r2,#11
000004  4290              CMP      r0,r2                 ;73
000006  d102              BNE      |L2.14|
000008  68cb              LDR      r3,[r1,#0xc]
00000a  1582              ASRS     r2,r0,#22
;;;76             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
00000c  e004              B        |L2.24|
                  |L2.14|
;;;77         }
;;;78         else if (i2c == I2C1)
00000e  4a08              LDR      r2,|L2.48|
000010  4290              CMP      r0,r2
000012  d106              BNE      |L2.34|
;;;79         {
;;;80             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
000014  68cb              LDR      r3,[r1,#0xc]
000016  1542              ASRS     r2,r0,#21
                  |L2.24|
000018  4313              ORRS     r3,r3,r2
00001a  60cb              STR      r3,[r1,#0xc]
;;;81             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
00001c  68cb              LDR      r3,[r1,#0xc]
00001e  4393              BICS     r3,r3,r2
000020  60cb              STR      r3,[r1,#0xc]
                  |L2.34|
;;;82         }
;;;83     
;;;84         /* Disable I2C */
;;;85         i2c->CTL0 &= ~I2C_CTL0_I2CEN_Msk;
000022  6801              LDR      r1,[r0,#0]
000024  2240              MOVS     r2,#0x40
000026  4391              BICS     r1,r1,r2
000028  6001              STR      r1,[r0,#0]
;;;86     }
00002a  4770              BX       lr
;;;87     
                          ENDP

                  |L2.44|
                          DCD      0x40080000
                  |L2.48|
                          DCD      0x40081000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;153      */
;;;154    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;155    {
;;;156        i2c->CTL0 &= ~I2C_CTL0_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;157    }
000008  4770              BX       lr
;;;158    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;394     */
;;;395    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;396    {
;;;397        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;398    }
000008  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;424     */
;;;425    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;426    {
;;;427        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;428    }
000008  4770              BX       lr
;;;429    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;168      */
;;;169    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;170    {
;;;171        i2c->CTL0 |= I2C_CTL0_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;172    }
000008  4770              BX       lr
;;;173    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;370     */
;;;371    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2202              MOVS     r2,#2
;;;372    {
;;;373        if (u8LongTimeout)
000002  2900              CMP      r1,#0
;;;374        {
;;;375            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;376        }
;;;377        else
;;;378        {
;;;379            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000004  6941              LDR      r1,[r0,#0x14]
000006  d001              BEQ      |L7.12|
000008  4311              ORRS     r1,r1,r2              ;375
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4391              BICS     r1,r1,r2
                  |L7.14|
00000e  6141              STR      r1,[r0,#0x14]
;;;380        }
;;;381    
;;;382        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6141              STR      r1,[r0,#0x14]
;;;383    }
000018  4770              BX       lr
;;;384    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;409     */
;;;410    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;411    {
;;;412        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  63c1              STR      r1,[r0,#0x3c]
;;;413    }
000008  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;182     */
;;;183    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185        uint32_t u32Divider = i2c->CLKDIV;
000002  6904              LDR      r4,[r0,#0x10]
;;;186        uint32_t u32Pclk;
;;;187    
;;;188        if (i2c == I2C1)
000004  4906              LDR      r1,|L9.32|
000006  4288              CMP      r0,r1
000008  d102              BNE      |L9.16|
;;;189        {
;;;190            u32Pclk = CLK_GetPCLK1Freq();
00000a  f7fffffe          BL       CLK_GetPCLK1Freq
00000e  e001              B        |L9.20|
                  |L9.16|
;;;191        }
;;;192        else
;;;193        {
;;;194            u32Pclk = CLK_GetPCLK0Freq();
000010  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L9.20|
;;;195        }
;;;196    
;;;197        return (u32Pclk / ((u32Divider + 1U) << 2U));
000014  00a1              LSLS     r1,r4,#2
000016  1d09              ADDS     r1,r1,#4
000018  f7fffffe          BL       __aeabi_uidivmod
;;;198    }
00001c  bd10              POP      {r4,pc}
;;;199    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40081000

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;266     */
;;;267    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;268    {
;;;269        return (uint8_t)(i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;270    }
000004  4770              BX       lr
;;;271    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;238     */
;;;239    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;240    {
;;;241        return ((i2c->CTL0 & I2C_CTL0_SI_Msk) == I2C_CTL0_SI_Msk ? 1U : 0U);
000002  0700              LSLS     r0,r0,#28
000004  0fc0              LSRS     r0,r0,#31
;;;242    }
000006  4770              BX       lr
;;;243    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;252     */
;;;253    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;254    {
;;;255        return (i2c->STATUS0);
;;;256    }
000002  4770              BX       lr
;;;257    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;35       */
;;;36     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  4605              MOV      r5,r0
;;;38         uint32_t u32Div;
;;;39         uint32_t u32Pclk;
;;;40     
;;;41         if (i2c == I2C1)
000004  480f              LDR      r0,|L13.68|
000006  460e              MOV      r6,r1                 ;37
000008  4285              CMP      r5,r0
00000a  d102              BNE      |L13.18|
;;;42         {
;;;43             u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L13.22|
                  |L13.18|
;;;44         }
;;;45         else
;;;46         {
;;;47             u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L13.22|
000016  4604              MOV      r4,r0
;;;48         }
;;;49     
;;;50         u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000018  220a              MOVS     r2,#0xa
00001a  00b1              LSLS     r1,r6,#2
00001c  4350              MULS     r0,r2,r0
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  210a              MOVS     r1,#0xa
000024  1d40              ADDS     r0,r0,#5
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  1e40              SUBS     r0,r0,#1
;;;51         i2c->CLKDIV = u32Div;
00002c  6128              STR      r0,[r5,#0x10]
;;;52     
;;;53         /* Enable I2C */
;;;54         i2c->CTL0 |= I2C_CTL0_I2CEN_Msk;
00002e  6829              LDR      r1,[r5,#0]
000030  2240              MOVS     r2,#0x40
000032  4311              ORRS     r1,r1,r2
000034  6029              STR      r1,[r5,#0]
;;;55     
;;;56         return (u32Pclk / ((u32Div + 1U) << 2U));
000036  0081              LSLS     r1,r0,#2
000038  4620              MOV      r0,r4
00003a  1d09              ADDS     r1,r1,#4
00003c  f7fffffe          BL       __aeabi_uidivmod
;;;57     }
000040  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

000042  0000              DCW      0x0000
                  |L13.68|
                          DCD      0x40081000

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;1087     */
;;;1088   uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1089   {
;;;1090       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  2300              MOVS     r3,#0
;;;1091   
;;;1092       I2C_START(i2c);                                          /* Send START */
000006  6802              LDR      r2,[r0,#0]
000008  461c              MOV      r4,r3                 ;1090
00000a  2628              MOVS     r6,#0x28
00000c  4332              ORRS     r2,r2,r6
00000e  6002              STR      r2,[r0,#0]
;;;1093   
;;;1094       while (u8Xfering && (u8Err == 0U))
;;;1095       {
;;;1096           I2C_WAIT_READY(i2c) {}
;;;1097   
;;;1098           switch (I2C_GET_STATUS(i2c))
;;;1099           {
;;;1100           case 0x08:
;;;1101               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
;;;1102               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1103               break;
;;;1104   
;;;1105           case 0x40:                                           /* Slave Address ACK */
;;;1106               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1107               break;
;;;1108   
;;;1109           case 0x48:                                           /* Slave Address NACK */
;;;1110               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1111               u8Err = 1U;
;;;1112               break;
;;;1113   
;;;1114           case 0x58:
;;;1115               rdata = (uint8_t) I2C_GET_DATA(i2c);       /* Receive Data */
;;;1116               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1117               u8Xfering = 0U;
;;;1118               break;
;;;1119   
;;;1120           case 0x38:                                           /* Arbitration Lost */
;;;1121           default:                                             /* Unknow status */
;;;1122               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L14.18|
000012  6802              LDR      r2,[r0,#0]            ;1096
000014  0712              LSLS     r2,r2,#28             ;1096
000016  d5fc              BPL      |L14.18|
000018  68c2              LDR      r2,[r0,#0xc]          ;1098
00001a  2a08              CMP      r2,#8                 ;1098
00001c  d00b              BEQ      |L14.54|
00001e  2a40              CMP      r2,#0x40              ;1098
000020  d00d              BEQ      |L14.62|
000022  2a48              CMP      r2,#0x48              ;1098
000024  d00d              BEQ      |L14.66|
000026  2a58              CMP      r2,#0x58              ;1098
000028  d00e              BEQ      |L14.72|
00002a  6802              LDR      r2,[r0,#0]
00002c  43b2              BICS     r2,r2,r6
00002e  3218              ADDS     r2,r2,#0x18
000030  6002              STR      r2,[r0,#0]
;;;1123               u8Ctrl = I2C_CTL_SI;
000032  2208              MOVS     r2,#8
;;;1124               u8Err = 1U;
;;;1125               break;
000034  e006              B        |L14.68|
                  |L14.54|
000036  004a              LSLS     r2,r1,#1              ;1101
000038  1c52              ADDS     r2,r2,#1              ;1101
00003a  b2d2              UXTB     r2,r2                 ;1101
00003c  6082              STR      r2,[r0,#8]            ;1101
                  |L14.62|
00003e  2208              MOVS     r2,#8                 ;1106
000040  e006              B        |L14.80|
                  |L14.66|
000042  2218              MOVS     r2,#0x18              ;1110
                  |L14.68|
000044  2301              MOVS     r3,#1                 ;1111
000046  e003              B        |L14.80|
                  |L14.72|
000048  6882              LDR      r2,[r0,#8]            ;1115
00004a  b2d4              UXTB     r4,r2                 ;1115
00004c  2218              MOVS     r2,#0x18              ;1116
00004e  2500              MOVS     r5,#0                 ;1117
                  |L14.80|
;;;1126           }
;;;1127   
;;;1128           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000050  6807              LDR      r7,[r0,#0]
000052  43b7              BICS     r7,r7,r6
000054  4317              ORRS     r7,r7,r2
000056  6007              STR      r7,[r0,#0]
000058  2d00              CMP      r5,#0                 ;1094
00005a  d002              BEQ      |L14.98|
00005c  2b00              CMP      r3,#0                 ;1094
00005e  d0d8              BEQ      |L14.18|
000060  e001              B        |L14.102|
                  |L14.98|
;;;1129       }
;;;1130   
;;;1131       if (u8Err)
000062  2b00              CMP      r3,#0
000064  d000              BEQ      |L14.104|
                  |L14.102|
;;;1132           rdata = 0U;                                           /* If occurs error, return 0 */
000066  2400              MOVS     r4,#0
                  |L14.104|
;;;1133   
;;;1134       return rdata;                                            /* Return read data */
000068  4620              MOV      r0,r4
;;;1135   }
00006a  bdf0              POP      {r4-r7,pc}
;;;1136   /**
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;1224     */
;;;1225   uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1226   {
;;;1227       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Ctrl = 0U;
000002  2601              MOVS     r6,#1
000004  2400              MOVS     r4,#0
;;;1228   
;;;1229       I2C_START(i2c);                                          /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  4625              MOV      r5,r4                 ;1227
00000a  4622              MOV      r2,r4                 ;1227
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;1230   
;;;1231       while (u8Xfering && (u8Err == 0U))
;;;1232       {
;;;1233           I2C_WAIT_READY(i2c) {}
;;;1234   
;;;1235           switch (I2C_GET_STATUS(i2c))
;;;1236           {
;;;1237           case 0x08:
;;;1238               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L15.20|
000014  6801              LDR      r1,[r0,#0]            ;1233
000016  0709              LSLS     r1,r1,#28             ;1233
000018  d5fc              BPL      |L15.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;1235
00001c  074b              LSLS     r3,r1,#29             ;1235
00001e  0f5b              LSRS     r3,r3,#29             ;1235
000020  d127              BNE      |L15.114|
000022  10c9              ASRS     r1,r1,#3              ;1235
000024  000b              MOVS     r3,r1                 ;1235
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c24              DCB      0x0c,0x24
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c2414          DCB      0x0f,0x0c,0x24,0x14
000034  0c241624          DCB      0x0c,0x24,0x16,0x24
000038  b2f9              UXTB     r1,r7
;;;1239               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1240               break;
00003a  e009              B        |L15.80|
;;;1241   
;;;1242           case 0x18:                                           /* Slave Address ACK */
;;;1243               I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;1244               break;
000040  e00d              B        |L15.94|
;;;1245   
;;;1246           case 0x20:                                           /* Slave Address NACK */
;;;1247           case 0x30:                                           /* Master transmit data NACK */
;;;1248               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L15.68|
;;;1249               u8Err = 1U;
000044  2401              MOVS     r4,#1
000046  e00a              B        |L15.94|
;;;1250               break;
;;;1251   
;;;1252           case 0x28:
;;;1253               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;1254               break;
00004a  e008              B        |L15.94|
;;;1255   
;;;1256           case 0x10:
;;;1257               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  b2c9              UXTB     r1,r1
                  |L15.80|
000050  6081              STR      r1,[r0,#8]            ;1238
;;;1258               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1259               break;
;;;1260   
;;;1261           case 0x40:                                           /* Slave Address ACK */
;;;1262               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
000052  2208              MOVS     r2,#8
;;;1263               break;
000054  e003              B        |L15.94|
;;;1264   
;;;1265           case 0x48:                                           /* Slave Address NACK */
;;;1266               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1267               u8Err = 1U;
;;;1268               break;
;;;1269   
;;;1270           case 0x58:
;;;1271               rdata = (uint8_t) I2C_GET_DATA(i2c);             /* Receive Data */
000056  6881              LDR      r1,[r0,#8]
;;;1272               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000058  2218              MOVS     r2,#0x18
00005a  b2cd              UXTB     r5,r1                 ;1271
;;;1273               u8Xfering = 0U;
00005c  2600              MOVS     r6,#0
                  |L15.94|
;;;1274               break;
;;;1275   
;;;1276           case 0x38:                                           /* Arbitration Lost */
;;;1277           default:                                             /* Unknow status */
;;;1278               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1279               u8Ctrl = I2C_CTL_SI;
;;;1280               u8Err = 1U;
;;;1281               break;
;;;1282           }
;;;1283   
;;;1284           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
00005e  6801              LDR      r1,[r0,#0]
000060  233c              MOVS     r3,#0x3c
000062  4399              BICS     r1,r1,r3
000064  4311              ORRS     r1,r1,r2
000066  6001              STR      r1,[r0,#0]
000068  2e00              CMP      r6,#0                 ;1231
00006a  d009              BEQ      |L15.128|
00006c  2c00              CMP      r4,#0                 ;1231
00006e  d0d1              BEQ      |L15.20|
000070  e008              B        |L15.132|
                  |L15.114|
000072  6801              LDR      r1,[r0,#0]            ;1278
000074  223c              MOVS     r2,#0x3c              ;1278
000076  4391              BICS     r1,r1,r2              ;1278
000078  3118              ADDS     r1,r1,#0x18           ;1278
00007a  6001              STR      r1,[r0,#0]            ;1278
00007c  2208              MOVS     r2,#8                 ;1279
00007e  e7e1              B        |L15.68|
                  |L15.128|
;;;1285       }
;;;1286   
;;;1287       if (u8Err)
000080  2c00              CMP      r4,#0
000082  d000              BEQ      |L15.134|
                  |L15.132|
;;;1288           rdata = 0U;                                           /* If occurs error, return 0 */
000084  2500              MOVS     r5,#0
                  |L15.134|
;;;1289   
;;;1290       return rdata;                                            /* Return read data */
000086  4628              MOV      r0,r5
;;;1291   }
000088  bdfe              POP      {r1-r7,pc}
;;;1292   
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1396     */
;;;1397   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1398   {
;;;1399       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1398
000006  2400              MOVS     r4,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1400   
;;;1401       I2C_START(i2c);                                                   /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  4625              MOV      r5,r4                 ;1399
000010  4622              MOV      r2,r4                 ;1399
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1402   
;;;1403       while (u8Xfering && (u8Err == 0U))
;;;1404       {
;;;1405           I2C_WAIT_READY(i2c) {}
;;;1406   
;;;1407           switch (I2C_GET_STATUS(i2c))
;;;1408           {
;;;1409           case 0x08:
;;;1410               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));             /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L16.26|
00001a  6801              LDR      r1,[r0,#0]            ;1405
00001c  0709              LSLS     r1,r1,#28             ;1405
00001e  d5fc              BPL      |L16.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1407
000022  074b              LSLS     r3,r1,#29             ;1407
000024  0f5b              LSRS     r3,r3,#29             ;1407
000026  d131              BNE      |L16.140|
000028  10c9              ASRS     r1,r1,#3              ;1407
00002a  000b              MOVS     r3,r1                 ;1407
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c2e0719          DCB      0x0c,0x2e,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  2e1c0d2e          DCB      0x2e,0x1c,0x0d,0x2e
00003c  1e2e              DCB      0x1e,0x2e
00003e  b2f9              UXTB     r1,r7
;;;1411               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1412               break;
000040  e011              B        |L16.102|
;;;1413   
;;;1414           case 0x18:                                                    /* Slave Address ACK */
;;;1415               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));/* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1416               break;
000048  e015              B        |L16.118|
;;;1417   
;;;1418           case 0x20:                                                    /* Slave Address NACK */
;;;1419           case 0x30:                                                    /* Master transmit data NACK */
;;;1420               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L16.76|
;;;1421               u8Err = 1U;
00004c  2401              MOVS     r4,#1
00004e  e012              B        |L16.118|
;;;1422               break;
;;;1423   
;;;1424           case 0x28:
;;;1425               if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L16.94|
;;;1426               {
;;;1427                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));     /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1428                   u8Addr = 0U;
00005a  2600              MOVS     r6,#0
00005c  e00b              B        |L16.118|
                  |L16.94|
;;;1429               }
;;;1430               else
;;;1431                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e009              B        |L16.118|
;;;1432   
;;;1433               break;
;;;1434   
;;;1435           case 0x10:
;;;1436               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));           /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  b2c9              UXTB     r1,r1
                  |L16.102|
000066  6081              STR      r1,[r0,#8]            ;1410
;;;1437               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1438               break;
;;;1439   
;;;1440           case 0x40:                                                    /* Slave Address ACK */
;;;1441               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
000068  2208              MOVS     r2,#8
;;;1442               break;
00006a  e004              B        |L16.118|
;;;1443   
;;;1444           case 0x48:                                                    /* Slave Address NACK */
;;;1445               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1446               u8Err = 1U;
;;;1447               break;
;;;1448   
;;;1449           case 0x58:
;;;1450               rdata = (uint8_t) I2C_GET_DATA(i2c);                /* Receive Data */
00006c  6881              LDR      r1,[r0,#8]
;;;1451               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00006e  2218              MOVS     r2,#0x18
000070  b2cd              UXTB     r5,r1                 ;1450
;;;1452               u8Xfering = 0U;
000072  2100              MOVS     r1,#0
000074  9100              STR      r1,[sp,#0]
                  |L16.118|
;;;1453               break;
;;;1454   
;;;1455           case 0x38:                                                    /* Arbitration Lost */
;;;1456           default:                                                      /* Unknow status */
;;;1457               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1458               u8Ctrl = I2C_CTL_SI;
;;;1459               u8Err = 1U;
;;;1460               break;
;;;1461           }
;;;1462   
;;;1463           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                             /* Write controlbit to I2C_CTL register */
000076  6801              LDR      r1,[r0,#0]
000078  233c              MOVS     r3,#0x3c
00007a  4399              BICS     r1,r1,r3
00007c  4311              ORRS     r1,r1,r2
00007e  6001              STR      r1,[r0,#0]
000080  9900              LDR      r1,[sp,#0]            ;1403
000082  2900              CMP      r1,#0                 ;1403
000084  d009              BEQ      |L16.154|
000086  2c00              CMP      r4,#0                 ;1403
000088  d0c7              BEQ      |L16.26|
00008a  e008              B        |L16.158|
                  |L16.140|
00008c  6801              LDR      r1,[r0,#0]            ;1457
00008e  223c              MOVS     r2,#0x3c              ;1457
000090  4391              BICS     r1,r1,r2              ;1457
000092  3118              ADDS     r1,r1,#0x18           ;1457
000094  6001              STR      r1,[r0,#0]            ;1457
000096  2208              MOVS     r2,#8                 ;1458
000098  e7d8              B        |L16.76|
                  |L16.154|
;;;1464       }
;;;1465   
;;;1466       if (u8Err)
00009a  2c00              CMP      r4,#0
00009c  d000              BEQ      |L16.160|
                  |L16.158|
;;;1467           rdata = 0U;                                                    /* If occurs error, return 0 */
00009e  2500              MOVS     r5,#0
                  |L16.160|
;;;1468   
;;;1469       return rdata;                                                     /* Return read data */
0000a0  4628              MOV      r0,r5
;;;1470   }
0000a2  b004              ADD      sp,sp,#0x10
0000a4  bdf0              POP      {r4-r7,pc}
;;;1471   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;1149     */
;;;1150   uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1151   {
000002  468c              MOV      r12,r1
;;;1152       uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  2600              MOVS     r6,#0
;;;1153       uint32_t u32rxLen = 0U;
;;;1154   
;;;1155       I2C_START(i2c);                                          /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  469e              MOV      lr,r3                 ;1151
00000c  4634              MOV      r4,r6                 ;1153
00000e  2528              MOVS     r5,#0x28
000010  4329              ORRS     r1,r1,r5
000012  6001              STR      r1,[r0,#0]
;;;1156   
;;;1157       while (u8Xfering && (u8Err == 0U))
;;;1158       {
;;;1159           I2C_WAIT_READY(i2c) {}
;;;1160   
;;;1161           switch (I2C_GET_STATUS(i2c))
;;;1162           {
;;;1163           case 0x08:
;;;1164               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
;;;1165               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1166               break;
;;;1167   
;;;1168           case 0x40:                                           /* Slave Address ACK */
;;;1169               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1170               break;
;;;1171   
;;;1172           case 0x48:                                           /* Slave Address NACK */
;;;1173               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1174               u8Err = 1;
;;;1175               break;
;;;1176   
;;;1177           case 0x50:
;;;1178               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);  /* Receive Data */
;;;1179   
;;;1180               if (u32rxLen < (u32rLen - 1))
;;;1181               {
;;;1182                   u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
;;;1183               }
;;;1184               else
;;;1185               {
;;;1186                   u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
;;;1187               }
;;;1188   
;;;1189               break;
;;;1190   
;;;1191           case 0x58:
;;;1192               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);  /* Receive Data */
;;;1193               u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;1194               u8Xfering = 0U;
;;;1195               break;
;;;1196   
;;;1197           case 0x38:                                                  /* Arbitration Lost */
;;;1198           default:                                                    /* Unknow status */
;;;1199               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);               /* Clear SI and send STOP */
000014  213c              MOVS     r1,#0x3c
                  |L17.22|
000016  6805              LDR      r5,[r0,#0]            ;1159
000018  072d              LSLS     r5,r5,#28             ;1159
00001a  d5fc              BPL      |L17.22|
00001c  68c5              LDR      r5,[r0,#0xc]          ;1161
00001e  2d48              CMP      r5,#0x48              ;1161
000020  d015              BEQ      |L17.78|
000022  dc04              BGT      |L17.46|
000024  2d08              CMP      r5,#8                 ;1161
000026  d00c              BEQ      |L17.66|
000028  2d40              CMP      r5,#0x40              ;1161
00002a  d104              BNE      |L17.54|
00002c  e019              B        |L17.98|
                  |L17.46|
00002e  2d50              CMP      r5,#0x50              ;1161
000030  d010              BEQ      |L17.84|
000032  2d58              CMP      r5,#0x58              ;1161
000034  d019              BEQ      |L17.106|
                  |L17.54|
000036  6805              LDR      r5,[r0,#0]
000038  438d              BICS     r5,r5,r1
00003a  3518              ADDS     r5,r5,#0x18
00003c  6005              STR      r5,[r0,#0]
;;;1200               u8Ctrl = I2C_CTL_SI;
00003e  2508              MOVS     r5,#8
;;;1201               u8Err = 1U;
;;;1202               break;
000040  e006              B        |L17.80|
                  |L17.66|
000042  4663              MOV      r3,r12                ;1164
000044  005d              LSLS     r5,r3,#1              ;1164
000046  1c6d              ADDS     r5,r5,#1              ;1164
000048  b2ed              UXTB     r5,r5                 ;1164
00004a  6085              STR      r5,[r0,#8]            ;1164
00004c  e00b              B        |L17.102|
                  |L17.78|
00004e  2518              MOVS     r5,#0x18              ;1173
                  |L17.80|
000050  2601              MOVS     r6,#1                 ;1174
000052  e00f              B        |L17.116|
                  |L17.84|
000054  6885              LDR      r5,[r0,#8]            ;1178
000056  5515              STRB     r5,[r2,r4]            ;1178
000058  4673              MOV      r3,lr                 ;1180
00005a  1e5b              SUBS     r3,r3,#1              ;1180
00005c  1c64              ADDS     r4,r4,#1              ;1180
00005e  429c              CMP      r4,r3                 ;1180
000060  d201              BCS      |L17.102|
                  |L17.98|
000062  250c              MOVS     r5,#0xc               ;1182
000064  e006              B        |L17.116|
                  |L17.102|
000066  2508              MOVS     r5,#8                 ;1186
000068  e004              B        |L17.116|
                  |L17.106|
00006a  6885              LDR      r5,[r0,#8]            ;1192
00006c  5515              STRB     r5,[r2,r4]            ;1192
00006e  2518              MOVS     r5,#0x18              ;1193
000070  2700              MOVS     r7,#0                 ;1194
000072  1c64              ADDS     r4,r4,#1              ;1194
                  |L17.116|
;;;1203           }
;;;1204   
;;;1205           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                           /* Write controlbit to I2C_CTL register */
000074  6803              LDR      r3,[r0,#0]
000076  438b              BICS     r3,r3,r1
000078  431d              ORRS     r5,r5,r3
00007a  6005              STR      r5,[r0,#0]
00007c  2f00              CMP      r7,#0                 ;1157
00007e  d001              BEQ      |L17.132|
000080  2e00              CMP      r6,#0                 ;1157
000082  d0c8              BEQ      |L17.22|
                  |L17.132|
;;;1206       }
;;;1207   
;;;1208       return u32rxLen;                                                /* Return bytes length that have been received */
000084  4620              MOV      r0,r4
;;;1209   }
000086  bdf0              POP      {r4-r7,pc}
;;;1210   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;1307     */
;;;1308   uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1309   {
;;;1310       uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000002  2601              MOVS     r6,#1
000004  2500              MOVS     r5,#0
;;;1311       uint32_t u32rxLen = 0U;
;;;1312   
;;;1313       I2C_START(i2c);                                          /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  462a              MOV      r2,r5                 ;1310
00000a  462c              MOV      r4,r5                 ;1311
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;1314   
;;;1315       while (u8Xfering && (u8Err == 0U))
;;;1316       {
;;;1317           I2C_WAIT_READY(i2c) {}
;;;1318   
;;;1319           switch (I2C_GET_STATUS(i2c))
;;;1320           {
;;;1321           case 0x08:
;;;1322               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L18.20|
000014  6801              LDR      r1,[r0,#0]            ;1317
000016  0709              LSLS     r1,r1,#28             ;1317
000018  d5fc              BPL      |L18.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;1319
00001c  074b              LSLS     r3,r1,#29             ;1319
00001e  0f5b              LSRS     r3,r3,#29             ;1319
000020  d136              BNE      |L18.144|
000022  10c9              ASRS     r1,r1,#3              ;1319
000024  000b              MOVS     r3,r1                 ;1319
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c33              DCB      0x0c,0x33
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c331d          DCB      0x0f,0x0c,0x33,0x1d
000034  0c152133          DCB      0x0c,0x15,0x21,0x33
000038  b2f9              UXTB     r1,r7
;;;1323               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1324               break;
00003a  e009              B        |L18.80|
;;;1325   
;;;1326           case 0x18:                                           /* Slave Address ACK */
;;;1327               I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;1328               break;
000040  e01a              B        |L18.120|
;;;1329   
;;;1330           case 0x20:                                           /* Slave Address NACK */
;;;1331           case 0x30:                                           /* Master transmit data NACK */
;;;1332               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L18.68|
;;;1333               u8Err = 1U;
000044  2501              MOVS     r5,#1
000046  e017              B        |L18.120|
;;;1334               break;
;;;1335   
;;;1336           case 0x28:
;;;1337               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;1338               break;
00004a  e015              B        |L18.120|
;;;1339   
;;;1340           case 0x10:
;;;1341               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  b2c9              UXTB     r1,r1
                  |L18.80|
000050  6081              STR      r1,[r0,#8]
000052  e009              B        |L18.104|
;;;1342               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1343               break;
;;;1344   
;;;1345           case 0x40:                                           /* Slave Address ACK */
;;;1346               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1347               break;
;;;1348   
;;;1349           case 0x48:                                           /* Slave Address NACK */
;;;1350               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1351               u8Err = 1U;
;;;1352               break;
;;;1353   
;;;1354           case 0x50:
;;;1355               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c); /* Receive Data */
000054  6881              LDR      r1,[r0,#8]
000056  9a03              LDR      r2,[sp,#0xc]
000058  5511              STRB     r1,[r2,r4]
;;;1356   
;;;1357               if (u32rxLen < (u32rLen - 1U))
00005a  9909              LDR      r1,[sp,#0x24]
00005c  1c64              ADDS     r4,r4,#1
00005e  1e49              SUBS     r1,r1,#1
000060  428c              CMP      r4,r1
000062  d201              BCS      |L18.104|
;;;1358                   u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
000064  220c              MOVS     r2,#0xc
000066  e007              B        |L18.120|
                  |L18.104|
;;;1359               else
;;;1360                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000068  2208              MOVS     r2,#8
00006a  e005              B        |L18.120|
;;;1361   
;;;1362               break;
;;;1363   
;;;1364           case 0x58:
;;;1365               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c); /* Receive Data */
00006c  6881              LDR      r1,[r0,#8]
00006e  9a03              LDR      r2,[sp,#0xc]
;;;1366               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1367               u8Xfering = 0U;
000070  2600              MOVS     r6,#0
000072  5511              STRB     r1,[r2,r4]            ;1365
000074  2218              MOVS     r2,#0x18              ;1366
000076  1c64              ADDS     r4,r4,#1
                  |L18.120|
;;;1368               break;
;;;1369   
;;;1370           case 0x38:                                           /* Arbitration Lost */
;;;1371           default:                                             /* Unknow status */
;;;1372               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1373               u8Ctrl = I2C_CTL_SI;
;;;1374               u8Err = 1U;
;;;1375               break;
;;;1376           }
;;;1377   
;;;1378           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000078  6801              LDR      r1,[r0,#0]
00007a  233c              MOVS     r3,#0x3c
00007c  4399              BICS     r1,r1,r3
00007e  4311              ORRS     r1,r1,r2
000080  6001              STR      r1,[r0,#0]
000082  2e00              CMP      r6,#0                 ;1315
000084  d001              BEQ      |L18.138|
000086  2d00              CMP      r5,#0                 ;1315
000088  d0c4              BEQ      |L18.20|
                  |L18.138|
;;;1379       }
;;;1380   
;;;1381       return u32rxLen;                                         /* Return bytes length that have been received */
00008a  4620              MOV      r0,r4
;;;1382   }
00008c  b004              ADD      sp,sp,#0x10
00008e  bdf0              POP      {r4-r7,pc}
                  |L18.144|
000090  6801              LDR      r1,[r0,#0]            ;1372
000092  223c              MOVS     r2,#0x3c              ;1372
000094  4391              BICS     r1,r1,r2              ;1372
000096  3118              ADDS     r1,r1,#0x18           ;1372
000098  6001              STR      r1,[r0,#0]            ;1372
00009a  2208              MOVS     r2,#8                 ;1373
00009c  e7d2              B        |L18.68|
;;;1383   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1486     */
;;;1487   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1488   {
;;;1489       uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1488
000006  2500              MOVS     r5,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1490       uint32_t u32rxLen = 0U;
;;;1491   
;;;1492       I2C_START(i2c);                                                   /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  462a              MOV      r2,r5                 ;1489
000010  462c              MOV      r4,r5                 ;1490
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1493   
;;;1494       while (u8Xfering && (u8Err == 0U))
;;;1495       {
;;;1496           I2C_WAIT_READY(i2c) {}
;;;1497   
;;;1498           switch (I2C_GET_STATUS(i2c))
;;;1499           {
;;;1500           case 0x08:
;;;1501               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));             /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L19.26|
00001a  6801              LDR      r1,[r0,#0]            ;1496
00001c  0709              LSLS     r1,r1,#28             ;1496
00001e  d5fc              BPL      |L19.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1498
000022  074b              LSLS     r3,r1,#29             ;1498
000024  0f5b              LSRS     r3,r3,#29             ;1498
000026  d140              BNE      |L19.170|
000028  10c9              ASRS     r1,r1,#3              ;1498
00002a  000b              MOVS     r3,r1                 ;1498
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c3d0719          DCB      0x0c,0x3d,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  3d250d1d          DCB      0x3d,0x25,0x0d,0x1d
00003c  293d              DCB      0x29,0x3d
00003e  b2f9              UXTB     r1,r7
;;;1502               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1503               break;
000040  e011              B        |L19.102|
;;;1504   
;;;1505           case 0x18:                                                    /* Slave Address ACK */
;;;1506               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));/* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1507               break;
000048  e022              B        |L19.144|
;;;1508   
;;;1509           case 0x20:                                                    /* Slave Address NACK */
;;;1510           case 0x30:                                                    /* Master transmit data NACK */
;;;1511               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L19.76|
;;;1512               u8Err = 1U;
00004c  2501              MOVS     r5,#1
00004e  e01f              B        |L19.144|
;;;1513               break;
;;;1514   
;;;1515           case 0x28:
;;;1516               if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L19.94|
;;;1517               {
;;;1518                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));     /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1519                   u8Addr = 0U;
00005a  2600              MOVS     r6,#0
00005c  e018              B        |L19.144|
                  |L19.94|
;;;1520               }
;;;1521               else
;;;1522                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e016              B        |L19.144|
;;;1523   
;;;1524               break;
;;;1525   
;;;1526           case 0x10:
;;;1527               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));           /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  b2c9              UXTB     r1,r1
                  |L19.102|
000066  6081              STR      r1,[r0,#8]
000068  e009              B        |L19.126|
;;;1528               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1529               break;
;;;1530   
;;;1531           case 0x40:                                                    /* Slave Address ACK */
;;;1532               u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1533               break;
;;;1534   
;;;1535           case 0x48:                                                    /* Slave Address NACK */
;;;1536               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1537               u8Err = 1U;
;;;1538               break;
;;;1539   
;;;1540           case 0x50:
;;;1541               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);    /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
00006c  9a04              LDR      r2,[sp,#0x10]
00006e  5511              STRB     r1,[r2,r4]
;;;1542   
;;;1543               if (u32rxLen < (u32rLen - 1U))
000070  990a              LDR      r1,[sp,#0x28]
000072  1c64              ADDS     r4,r4,#1
000074  1e49              SUBS     r1,r1,#1
000076  428c              CMP      r4,r1
000078  d201              BCS      |L19.126|
;;;1544               {
;;;1545                   u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
00007a  220c              MOVS     r2,#0xc
00007c  e008              B        |L19.144|
                  |L19.126|
;;;1546               }
;;;1547               else
;;;1548               {
;;;1549                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
00007e  2208              MOVS     r2,#8
000080  e006              B        |L19.144|
;;;1550               }
;;;1551   
;;;1552               break;
;;;1553   
;;;1554           case 0x58:
;;;1555               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);    /* Receive Data */
000082  6882              LDR      r2,[r0,#8]
000084  9904              LDR      r1,[sp,#0x10]
000086  550a              STRB     r2,[r1,r4]
;;;1556               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1557               u8Xfering = 0U;
000088  2100              MOVS     r1,#0
00008a  2218              MOVS     r2,#0x18              ;1556
00008c  1c64              ADDS     r4,r4,#1
00008e  9100              STR      r1,[sp,#0]
                  |L19.144|
;;;1558               break;
;;;1559   
;;;1560           case 0x38:                                                    /* Arbitration Lost */
;;;1561           default:                                                      /* Unknow status */
;;;1562               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1563               u8Ctrl = I2C_CTL_SI;
;;;1564               u8Err = 1U;
;;;1565               break;
;;;1566           }
;;;1567   
;;;1568           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                             /* Write controlbit to I2C_CTL register */
000090  6801              LDR      r1,[r0,#0]
000092  233c              MOVS     r3,#0x3c
000094  4399              BICS     r1,r1,r3
000096  4311              ORRS     r1,r1,r2
000098  6001              STR      r1,[r0,#0]
00009a  9900              LDR      r1,[sp,#0]            ;1494
00009c  2900              CMP      r1,#0                 ;1494
00009e  d001              BEQ      |L19.164|
0000a0  2d00              CMP      r5,#0                 ;1494
0000a2  d0ba              BEQ      |L19.26|
                  |L19.164|
;;;1569       }
;;;1570   
;;;1571       return u32rxLen;                                                  /* Return bytes length that have been received */
0000a4  4620              MOV      r0,r4
;;;1572   }
0000a6  b005              ADD      sp,sp,#0x14
0000a8  bdf0              POP      {r4-r7,pc}
                  |L19.170|
0000aa  6801              LDR      r1,[r0,#0]            ;1562
0000ac  223c              MOVS     r2,#0x3c              ;1562
0000ae  4391              BICS     r1,r1,r2              ;1562
0000b0  3118              ADDS     r1,r1,#0x18           ;1562
0000b2  6001              STR      r1,[r0,#0]            ;1562
0000b4  2208              MOVS     r2,#8                 ;1563
0000b6  e7c9              B        |L19.76|
;;;1573   
                          ENDP


                          AREA ||i.I2C_SMBusClearInterruptFlag||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClearInterruptFlag PROC
;;;455     */
;;;456    void I2C_SMBusClearInterruptFlag(I2C_T *i2c, uint8_t u8SMBusIntFlag)
000000  6581              STR      r1,[r0,#0x58]
;;;457    {
;;;458        i2c->BUSSTS = u8SMBusIntFlag;
;;;459    }
000002  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.I2C_SMBusClockLoTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClockLoTimeout PROC
;;;640    
;;;641    void I2C_SMBusClockLoTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  b570              PUSH     {r4-r6,lr}
;;;642    {
000002  4604              MOV      r4,r0
;;;643        uint32_t u32Div, u32Pclk_kHz;
;;;644    
;;;645        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000004  6d00              LDR      r0,[r0,#0x50]
000006  460d              MOV      r5,r1                 ;642
000008  2101              MOVS     r1,#1
00000a  0249              LSLS     r1,r1,#9
00000c  4388              BICS     r0,r0,r1
00000e  6520              STR      r0,[r4,#0x50]
;;;646    
;;;647        /* DIV4 disabled */
;;;648        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000010  6960              LDR      r0,[r4,#0x14]
000012  2604              MOVS     r6,#4
000014  43b0              BICS     r0,r0,r6
000016  6160              STR      r0,[r4,#0x14]
;;;649        u32Pclk_kHz = u32Pclk / 1000U;
000018  217d              MOVS     r1,#0x7d
00001a  00c9              LSLS     r1,r1,#3
00001c  4610              MOV      r0,r2
00001e  f7fffffe          BL       __aeabi_uidivmod
;;;650        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000022  4345              MULS     r5,r0,r5
000024  0ba8              LSRS     r0,r5,#14
000026  1e40              SUBS     r0,r0,#1
;;;651        if(u32Div <= 0xFFU)
000028  28ff              CMP      r0,#0xff
00002a  d905              BLS      |L21.56|
;;;652        {
;;;653            i2c->CLKTOUT = u32Div;
;;;654        }
;;;655        else
;;;656        {
;;;657            /* DIV4 enabled */
;;;658            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
00002c  6960              LDR      r0,[r4,#0x14]
00002e  4330              ORRS     r0,r0,r6
000030  6160              STR      r0,[r4,#0x14]
;;;659            i2c->CLKTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
000032  0c28              LSRS     r0,r5,#16
000034  1e40              SUBS     r0,r0,#1
000036  b2c0              UXTB     r0,r0
                  |L21.56|
000038  66a0              STR      r0,[r4,#0x68]         ;653
;;;660        }
;;;661    }
00003a  bd70              POP      {r4-r6,pc}
;;;662    
                          ENDP


                          AREA ||i.I2C_SMBusClose||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClose PROC
;;;513     */
;;;514    void I2C_SMBusClose(I2C_T *i2c)
000000  2100              MOVS     r1,#0
;;;515    {
;;;516    
;;;517        i2c->BUSCTL = 0x00U;
000002  6501              STR      r1,[r0,#0x50]
;;;518    }
000004  4770              BX       lr
;;;519    
                          ENDP


                          AREA ||i.I2C_SMBusGetPECValue||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetPECValue PROC
;;;554     */
;;;555    uint8_t I2C_SMBusGetPECValue(I2C_T *i2c)
000000  6e00              LDR      r0,[r0,#0x60]
;;;556    {
;;;557        return (uint8_t)i2c->PKTCRC;
000002  b2c0              UXTB     r0,r0
;;;558    }
000004  4770              BX       lr
;;;559    
                          ENDP


                          AREA ||i.I2C_SMBusGetStatus||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetStatus PROC
;;;439     */
;;;440    uint32_t I2C_SMBusGetStatus(I2C_T *i2c)
000000  6d80              LDR      r0,[r0,#0x58]
;;;441    {
;;;442        return (i2c->BUSSTS);
;;;443    }
000002  4770              BX       lr
;;;444    
                          ENDP


                          AREA ||i.I2C_SMBusIdleTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusIdleTimeout PROC
;;;572    
;;;573    void I2C_SMBusIdleTimeout(I2C_T *i2c, uint32_t us, uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;574    {
000002  4604              MOV      r4,r0
;;;575        uint32_t  u32Div, u32Hclk_kHz;
;;;576    
;;;577        i2c->BUSCTL |= I2C_BUSCTL_TIDLE_Msk;
000004  6d00              LDR      r0,[r0,#0x50]
000006  460e              MOV      r6,r1                 ;574
000008  2101              MOVS     r1,#1
00000a  0249              LSLS     r1,r1,#9
00000c  4308              ORRS     r0,r0,r1
00000e  6520              STR      r0,[r4,#0x50]
;;;578        u32Hclk_kHz = u32Hclk / 1000U;
000010  257d              MOVS     r5,#0x7d
000012  00ed              LSLS     r5,r5,#3
000014  4629              MOV      r1,r5
000016  4610              MOV      r0,r2
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  4601              MOV      r1,r0
00001e  4630              MOV      r0,r6
;;;579        u32Div = (((us * u32Hclk_kHz) / 1000U) >> 2U) - 1U;
000020  4348              MULS     r0,r1,r0
000022  4629              MOV      r1,r5
000024  f7fffffe          BL       __aeabi_uidivmod
000028  0880              LSRS     r0,r0,#2
00002a  1e40              SUBS     r0,r0,#1
;;;580        if(u32Div > 255U)
00002c  28ff              CMP      r0,#0xff
00002e  d900              BLS      |L25.50|
;;;581        {
;;;582            i2c->BUSTOUT = 0xFFU;
000030  20ff              MOVS     r0,#0xff
                  |L25.50|
;;;583        }
;;;584        else
;;;585        {
;;;586            i2c->BUSTOUT = u32Div;
000032  6660              STR      r0,[r4,#0x64]
;;;587        }
;;;588    
;;;589    }
000034  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP


                          AREA ||i.I2C_SMBusOpen||, CODE, READONLY, ALIGN=1

                  I2C_SMBusOpen PROC
;;;487     */
;;;488    void I2C_SMBusOpen(I2C_T *i2c, uint8_t u8HostDevice)
000000  6d02              LDR      r2,[r0,#0x50]
;;;489    {
;;;490        /* Clear  BMHEN, BMDEN of BUSCTL Register */
;;;491        i2c->BUSCTL &=  ~(I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BMDEN_Msk);
000002  230c              MOVS     r3,#0xc
000004  439a              BICS     r2,r2,r3
000006  6502              STR      r2,[r0,#0x50]
;;;492    
;;;493        /* Set SMBus Host/Device Mode, and enable Bus Management*/
;;;494        if(u8HostDevice == (uint8_t)I2C_SMBH_ENABLE)
000008  2901              CMP      r1,#1
;;;495        {
;;;496            i2c->BUSCTL |= (I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BUSEN_Msk);
;;;497        }
;;;498        else
;;;499        {
;;;500            i2c->BUSCTL |= (I2C_BUSCTL_BMDEN_Msk | I2C_BUSCTL_BUSEN_Msk);
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  d003              BEQ      |L26.22|
00000e  2284              MOVS     r2,#0x84
                  |L26.16|
000010  4311              ORRS     r1,r1,r2              ;496
000012  6501              STR      r1,[r0,#0x50]         ;496
;;;501        }
;;;502    }
000014  4770              BX       lr
                  |L26.22|
000016  2288              MOVS     r2,#0x88              ;496
000018  e7fa              B        |L26.16|
;;;503    
                          ENDP


                          AREA ||i.I2C_SMBusPECTxEnable||, CODE, READONLY, ALIGN=1

                  I2C_SMBusPECTxEnable PROC
;;;530     */
;;;531    void I2C_SMBusPECTxEnable(I2C_T *i2c, uint8_t u8PECTxEn)
000000  6d02              LDR      r2,[r0,#0x50]
;;;532    {
;;;533        i2c->BUSCTL &= ~I2C_BUSCTL_PECTXEN_Msk;
000002  23ff              MOVS     r3,#0xff
000004  3301              ADDS     r3,#1
000006  439a              BICS     r2,r2,r3
000008  6502              STR      r2,[r0,#0x50]
;;;534    
;;;535        if(u8PECTxEn)
00000a  2900              CMP      r1,#0
;;;536        {
;;;537            i2c->BUSCTL |= (I2C_BUSCTL_PECEN_Msk | I2C_BUSCTL_PECTXEN_Msk);
;;;538        }
;;;539        else
;;;540        {
;;;541            i2c->BUSCTL |= I2C_BUSCTL_PECEN_Msk;
00000c  6d01              LDR      r1,[r0,#0x50]
00000e  d001              BEQ      |L27.20|
000010  1c9a              ADDS     r2,r3,#2              ;537
000012  e000              B        |L27.22|
                  |L27.20|
000014  2202              MOVS     r2,#2
                  |L27.22|
000016  4311              ORRS     r1,r1,r2              ;537
000018  6501              STR      r1,[r0,#0x50]         ;537
;;;542        }
;;;543    }
00001a  4770              BX       lr
;;;544    
                          ENDP


                          AREA ||i.I2C_SMBusSetPacketByteCount||, CODE, READONLY, ALIGN=1

                  I2C_SMBusSetPacketByteCount PROC
;;;471     */
;;;472    void I2C_SMBusSetPacketByteCount(I2C_T *i2c, uint32_t u32PktSize)
000000  65c1              STR      r1,[r0,#0x5c]
;;;473    {
;;;474        i2c->PKTSIZE = u32PktSize;
;;;475    }
000002  4770              BX       lr
;;;476    
                          ENDP


                          AREA ||i.I2C_SMBusTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusTimeout PROC
;;;604    
;;;605    void I2C_SMBusTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  b570              PUSH     {r4-r6,lr}
;;;606    {
000002  4604              MOV      r4,r0
;;;607        uint32_t u32Div, u32Pclk_kHz;
;;;608    
;;;609        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000004  6d00              LDR      r0,[r0,#0x50]
000006  460d              MOV      r5,r1                 ;606
000008  2101              MOVS     r1,#1
00000a  0249              LSLS     r1,r1,#9
00000c  4388              BICS     r0,r0,r1
00000e  6520              STR      r0,[r4,#0x50]
;;;610    
;;;611        /* DIV4 disabled */
;;;612        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000010  6960              LDR      r0,[r4,#0x14]
000012  2604              MOVS     r6,#4
000014  43b0              BICS     r0,r0,r6
000016  6160              STR      r0,[r4,#0x14]
;;;613        u32Pclk_kHz = u32Pclk / 1000U;
000018  217d              MOVS     r1,#0x7d
00001a  00c9              LSLS     r1,r1,#3
00001c  4610              MOV      r0,r2
00001e  f7fffffe          BL       __aeabi_uidivmod
;;;614        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000022  4345              MULS     r5,r0,r5
000024  0ba8              LSRS     r0,r5,#14
000026  1e40              SUBS     r0,r0,#1
;;;615        if(u32Div <= 0xFFU)
000028  28ff              CMP      r0,#0xff
00002a  d905              BLS      |L29.56|
;;;616        {
;;;617            i2c->BUSTOUT = u32Div;
;;;618        }
;;;619        else
;;;620        {
;;;621            /* DIV4 enabled */
;;;622            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
00002c  6960              LDR      r0,[r4,#0x14]
00002e  4330              ORRS     r0,r0,r6
000030  6160              STR      r0,[r4,#0x14]
;;;623            i2c->BUSTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
000032  0c28              LSRS     r0,r5,#16
000034  1e40              SUBS     r0,r0,#1
000036  b2c0              UXTB     r0,r0
                  |L29.56|
000038  6660              STR      r0,[r4,#0x64]         ;617
;;;624        }
;;;625    }
00003a  bd70              POP      {r4-r6,pc}
;;;626    
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;209     */
;;;210    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;211    {
000002  4605              MOV      r5,r0
;;;212        uint32_t u32Div;
;;;213        uint32_t u32Pclk;
;;;214    
;;;215        if (i2c == I2C1)
000004  480d              LDR      r0,|L30.60|
000006  460e              MOV      r6,r1                 ;211
000008  4285              CMP      r5,r0
00000a  d102              BNE      |L30.18|
;;;216        {
;;;217            u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L30.22|
                  |L30.18|
;;;218        }
;;;219        else
;;;220        {
;;;221            u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L30.22|
000016  4604              MOV      r4,r0
;;;222        }
;;;223    
;;;224        u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000018  220a              MOVS     r2,#0xa
00001a  00b1              LSLS     r1,r6,#2
00001c  4350              MULS     r0,r2,r0
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  210a              MOVS     r1,#0xa
000024  1d40              ADDS     r0,r0,#5
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  1e40              SUBS     r0,r0,#1
;;;225        i2c->CLKDIV = u32Div;
00002c  6128              STR      r0,[r5,#0x10]
;;;226    
;;;227        return (u32Pclk / ((u32Div + 1U) << 2U));
00002e  0081              LSLS     r1,r0,#2
000030  4620              MOV      r0,r4
000032  1d09              ADDS     r1,r1,#4
000034  f7fffffe          BL       __aeabi_uidivmod
;;;228    }
000038  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

00003a  0000              DCW      0x0000
                  |L30.60|
                          DCD      0x40081000

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;281     */
;;;282    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;283    {
;;;284        i2c->DAT = u8Data;
;;;285    }
000002  4770              BX       lr
;;;286    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;300     */
;;;301    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  0052              LSLS     r2,r2,#1
;;;302    {
;;;303        switch (u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d006              BEQ      |L32.20|
000006  2902              CMP      r1,#2
000008  d006              BEQ      |L32.24|
00000a  2903              CMP      r1,#3
00000c  d006              BEQ      |L32.28|
;;;304        {
;;;305        case 1:
;;;306            i2c->ADDR1  = ((uint32_t)u8SlaveAddr << 1U);
;;;307            break;
;;;308    
;;;309        case 2:
;;;310            i2c->ADDR2  = ((uint32_t)u8SlaveAddr << 1U);
;;;311            break;
;;;312    
;;;313        case 3:
;;;314            i2c->ADDR3  = ((uint32_t)u8SlaveAddr << 1U);
;;;315            break;
;;;316    
;;;317        case 0:
;;;318        default:
;;;319            i2c->ADDR0  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
00000e  431a              ORRS     r2,r2,r3
000010  6042              STR      r2,[r0,#4]
;;;320            break;
;;;321        }
;;;322    }
000012  4770              BX       lr
                  |L32.20|
000014  6182              STR      r2,[r0,#0x18]         ;306
000016  4770              BX       lr
                  |L32.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;310
00001a  4770              BX       lr
                  |L32.28|
00001c  6202              STR      r2,[r0,#0x20]         ;314
00001e  4770              BX       lr
;;;323    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;335     */
;;;336    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;337    {
;;;338        switch (u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L33.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L33.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L33.26|
;;;339        {
;;;340        case 1:
;;;341            i2c->ADDRMSK1  = (uint32_t)u8SlaveAddrMask << 1U;
;;;342            break;
;;;343    
;;;344        case 2:
;;;345            i2c->ADDRMSK2  = (uint32_t)u8SlaveAddrMask << 1U;
;;;346            break;
;;;347    
;;;348        case 3:
;;;349            i2c->ADDRMSK3  = (uint32_t)u8SlaveAddrMask << 1U;
;;;350            break;
;;;351    
;;;352        case 0:
;;;353        default:
;;;354            i2c->ADDRMSK0  = (uint32_t)u8SlaveAddrMask << 1U;
00000e  6242              STR      r2,[r0,#0x24]
;;;355            break;
;;;356        }
;;;357    }
000010  4770              BX       lr
                  |L33.18|
000012  6282              STR      r2,[r0,#0x28]         ;341
000014  4770              BX       lr
                  |L33.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;345
000018  4770              BX       lr
                  |L33.26|
00001a  6302              STR      r2,[r0,#0x30]         ;349
00001c  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;116      */
;;;117    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
;;;119        uint32_t u32Reg = 0U;
000002  2400              MOVS     r4,#0
;;;120    
;;;121        if (u8Start)
000004  9d03              LDR      r5,[sp,#0xc]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L34.12|
;;;122        {
;;;123            u32Reg |= I2C_CTL_STA;
00000a  2420              MOVS     r4,#0x20
                  |L34.12|
;;;124        }
;;;125    
;;;126        if (u8Stop)
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L34.20|
;;;127        {
;;;128            u32Reg |= I2C_CTL_STO;
000010  2110              MOVS     r1,#0x10
000012  430c              ORRS     r4,r4,r1
                  |L34.20|
;;;129        }
;;;130    
;;;131        if (u8Si)
000014  2b00              CMP      r3,#0
000016  d001              BEQ      |L34.28|
;;;132        {
;;;133            u32Reg |= I2C_CTL_SI;
000018  2108              MOVS     r1,#8
00001a  430c              ORRS     r4,r4,r1
                  |L34.28|
;;;134        }
;;;135    
;;;136        if (u8Ack)
00001c  2d00              CMP      r5,#0
00001e  d001              BEQ      |L34.36|
;;;137        {
;;;138            u32Reg |= I2C_CTL_AA;
000020  2104              MOVS     r1,#4
000022  430c              ORRS     r4,r4,r1
                  |L34.36|
;;;139        }
;;;140    
;;;141        i2c->CTL0 = (i2c->CTL0 & ~0x3CU) | u32Reg;
000024  6801              LDR      r1,[r0,#0]
000026  223c              MOVS     r2,#0x3c
000028  4391              BICS     r1,r1,r2
00002a  4321              ORRS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
;;;142    }
00002e  bd30              POP      {r4,r5,pc}
;;;143    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;676    
;;;677    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;678    {
;;;679        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  2400              MOVS     r4,#0
;;;680    
;;;681        I2C_START(i2c);
000006  6806              LDR      r6,[r0,#0]
000008  4623              MOV      r3,r4                 ;679
00000a  2728              MOVS     r7,#0x28
00000c  433e              ORRS     r6,r6,r7
00000e  6006              STR      r6,[r0,#0]
;;;682    
;;;683        while (u8Xfering && (u8Err == 0U))
;;;684        {
;;;685            I2C_WAIT_READY(i2c) {}
;;;686    
;;;687            switch (I2C_GET_STATUS(i2c))
;;;688            {
;;;689            case 0x08:
;;;690                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Write SLA+W to Register I2CDAT */
;;;691                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;692                break;
;;;693    
;;;694            case 0x18:                                         /* Slave Address ACK */
;;;695                I2C_SET_DATA(i2c, data);                       /* Write data to I2CDAT */
;;;696                break;
;;;697    
;;;698            case 0x20:                                         /* Slave Address NACK */
;;;699            case 0x30:                                         /* Master transmit data NACK */
;;;700                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;701                u8Err = 1U;
;;;702                break;
;;;703    
;;;704            case 0x28:
;;;705                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;706                u8Xfering = 0U;
;;;707                break;
;;;708    
;;;709            case 0x38:                                         /* Arbitration Lost */
;;;710            default:                                           /* Unknow status */
;;;711                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L35.18|
000012  6807              LDR      r7,[r0,#0]            ;685
000014  073f              LSLS     r7,r7,#28             ;685
000016  d5fc              BPL      |L35.18|
000018  68c7              LDR      r7,[r0,#0xc]          ;687
00001a  2f20              CMP      r7,#0x20              ;687
00001c  d016              BEQ      |L35.76|
00001e  dc04              BGT      |L35.42|
000020  2f08              CMP      r7,#8                 ;687
000022  d00c              BEQ      |L35.62|
000024  2f18              CMP      r7,#0x18              ;687
000026  d104              BNE      |L35.50|
000028  e00e              B        |L35.72|
                  |L35.42|
00002a  2f28              CMP      r7,#0x28              ;687
00002c  d011              BEQ      |L35.82|
00002e  2f30              CMP      r7,#0x30              ;687
000030  d00c              BEQ      |L35.76|
                  |L35.50|
000032  6803              LDR      r3,[r0,#0]
000034  43b3              BICS     r3,r3,r6
000036  3318              ADDS     r3,r3,#0x18
000038  6003              STR      r3,[r0,#0]
;;;712                u8Ctrl = I2C_CTL_SI;
00003a  2308              MOVS     r3,#8
;;;713                u8Err = 1U;
;;;714                break;
00003c  e007              B        |L35.78|
                  |L35.62|
00003e  064b              LSLS     r3,r1,#25             ;690
000040  0e1b              LSRS     r3,r3,#24             ;690
000042  6083              STR      r3,[r0,#8]            ;690
000044  2308              MOVS     r3,#8                 ;691
000046  e006              B        |L35.86|
                  |L35.72|
000048  6082              STR      r2,[r0,#8]            ;695
00004a  e004              B        |L35.86|
                  |L35.76|
00004c  2318              MOVS     r3,#0x18              ;700
                  |L35.78|
00004e  2401              MOVS     r4,#1                 ;701
000050  e001              B        |L35.86|
                  |L35.82|
000052  2318              MOVS     r3,#0x18              ;705
000054  2500              MOVS     r5,#0                 ;706
                  |L35.86|
;;;715            }
;;;716    
;;;717            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
000056  6807              LDR      r7,[r0,#0]
000058  43b7              BICS     r7,r7,r6
00005a  431f              ORRS     r7,r7,r3
00005c  6007              STR      r7,[r0,#0]
00005e  2d00              CMP      r5,#0                 ;683
000060  d001              BEQ      |L35.102|
000062  2c00              CMP      r4,#0                 ;683
000064  d0d5              BEQ      |L35.18|
                  |L35.102|
000066  4620              MOV      r0,r4                 ;683
;;;718        }
;;;719    
;;;720        return (u8Err | u8Xfering);                            /* return (Success)/(Fail) status */
000068  4328              ORRS     r0,r0,r5
;;;721    }
00006a  bdf0              POP      {r4-r7,pc}
;;;722    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;801    
;;;802    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;803    {
000002  469e              MOV      lr,r3
;;;804        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2601              MOVS     r6,#1
000006  4613              MOV      r3,r2                 ;803
000008  2500              MOVS     r5,#0
;;;805        uint32_t u32txLen = 0U;
;;;806    
;;;807        I2C_START(i2c);                                        /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;803
00000e  462c              MOV      r4,r5                 ;804
000010  462f              MOV      r7,r5                 ;805
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;808    
;;;809        while (u8Xfering && (u8Err == 0U))
;;;810        {
;;;811            I2C_WAIT_READY(i2c) {}
;;;812    
;;;813            switch (I2C_GET_STATUS(i2c))
;;;814            {
;;;815            case 0x08:
;;;816                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Send Slave address with write bit */
;;;817                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;818                break;
;;;819    
;;;820            case 0x18:                                         /* Slave Address ACK */
;;;821                I2C_SET_DATA(i2c, u8DataAddr);                 /* Write Lo byte address of register */
;;;822                break;
;;;823    
;;;824            case 0x20:                                         /* Slave Address NACK */
;;;825            case 0x30:                                         /* Master transmit data NACK */
;;;826                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;827                u8Err = 1U;
;;;828                break;
;;;829    
;;;830            case 0x28:
;;;831                if (u32txLen < 1U)
;;;832                {
;;;833                    I2C_SET_DATA(i2c, data);
;;;834                    u32txLen++;
;;;835                }
;;;836                else
;;;837                {
;;;838                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;839                    u8Xfering = 0U;
;;;840                }
;;;841    
;;;842                break;
;;;843    
;;;844            case 0x38:                                         /* Arbitration Lost */
;;;845            default:                                           /* Unknow status */
;;;846                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L36.26|
00001a  6801              LDR      r1,[r0,#0]            ;811
00001c  0709              LSLS     r1,r1,#28             ;811
00001e  d5fc              BPL      |L36.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;813
000022  2920              CMP      r1,#0x20              ;813
000024  d017              BEQ      |L36.86|
000026  dc04              BGT      |L36.50|
000028  2908              CMP      r1,#8                 ;813
00002a  d00c              BEQ      |L36.70|
00002c  2918              CMP      r1,#0x18              ;813
00002e  d104              BNE      |L36.58|
000030  e00f              B        |L36.82|
                  |L36.50|
000032  2928              CMP      r1,#0x28              ;813
000034  d012              BEQ      |L36.92|
000036  2930              CMP      r1,#0x30              ;813
000038  d00d              BEQ      |L36.86|
                  |L36.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;847                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;848                u8Err = 1U;
;;;849                break;
000044  e008              B        |L36.88|
                  |L36.70|
000046  4661              MOV      r1,r12                ;816
000048  064c              LSLS     r4,r1,#25             ;816
00004a  0e24              LSRS     r4,r4,#24             ;816
00004c  6084              STR      r4,[r0,#8]            ;816
00004e  2408              MOVS     r4,#8                 ;817
000050  e00c              B        |L36.108|
                  |L36.82|
000052  6083              STR      r3,[r0,#8]            ;821
000054  e00a              B        |L36.108|
                  |L36.86|
000056  2418              MOVS     r4,#0x18              ;826
                  |L36.88|
000058  2501              MOVS     r5,#1                 ;827
00005a  e007              B        |L36.108|
                  |L36.92|
00005c  2f00              CMP      r7,#0                 ;831
00005e  d002              BEQ      |L36.102|
000060  2418              MOVS     r4,#0x18              ;838
000062  2600              MOVS     r6,#0                 ;839
000064  e002              B        |L36.108|
                  |L36.102|
000066  4671              MOV      r1,lr                 ;833
000068  6081              STR      r1,[r0,#8]            ;833
00006a  2701              MOVS     r7,#1                 ;834
                  |L36.108|
;;;850            }
;;;851    
;;;852            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
00006c  6801              LDR      r1,[r0,#0]
00006e  4391              BICS     r1,r1,r2
000070  4321              ORRS     r1,r1,r4
000072  6001              STR      r1,[r0,#0]
000074  2e00              CMP      r6,#0                 ;809
000076  d001              BEQ      |L36.124|
000078  2d00              CMP      r5,#0                 ;809
00007a  d0ce              BEQ      |L36.26|
                  |L36.124|
00007c  4628              MOV      r0,r5                 ;809
;;;853        }
;;;854    
;;;855        return (u8Err | u8Xfering);                            /* return (Success)/(Fail) status */
00007e  4330              ORRS     r0,r0,r6
;;;856    }
000080  bdf0              POP      {r4-r7,pc}
;;;857    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;941    
;;;942    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data)
000000  b5ff              PUSH     {r0-r7,lr}
;;;943    {
;;;944        uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  468e              MOV      lr,r1                 ;943
000006  2400              MOVS     r4,#0
;;;945        uint32_t u32txLen = 0U;
;;;946    
;;;947        I2C_START(i2c);                                                     /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;943
00000c  462f              MOV      r7,r5                 ;944
00000e  4623              MOV      r3,r4                 ;944
000010  4626              MOV      r6,r4                 ;945
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L37.24|
;;;948    
;;;949        while (u8Xfering && (u8Err == 0U))
;;;950        {
;;;951            I2C_WAIT_READY(i2c) {}
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L37.24|
;;;952    
;;;953            switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d01a              BEQ      |L37.90|
000024  dc04              BGT      |L37.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L37.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L37.56|
00002e  e010              B        |L37.82|
                  |L37.48|
000030  2a28              CMP      r2,#0x28
000032  d015              BEQ      |L37.96|
000034  2a30              CMP      r2,#0x30
000036  d010              BEQ      |L37.90|
                  |L37.56|
;;;954            {
;;;955            case 0x08:
;;;956                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));               /* Write SLA+W to Register I2CDAT */
;;;957                u8Ctrl = I2C_CTL_SI;                                        /* Clear SI */
;;;958                break;
;;;959    
;;;960            case 0x18:                                                      /* Slave Address ACK */
;;;961                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte address of register */
;;;962                break;
;;;963    
;;;964            case 0x20:                                                      /* Slave Address NACK */
;;;965            case 0x30:                                                      /* Master transmit data NACK */
;;;966                u8Ctrl = I2C_CTL_STO_SI;                                    /* Clear SI and send STOP */
;;;967                u8Err = 1;
;;;968                break;
;;;969    
;;;970            case 0x28:
;;;971                if (u8Addr)
;;;972                {
;;;973                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));       /* Write Lo byte address of register */
;;;974                    u8Addr = 0U;
;;;975                }
;;;976                else if ((u32txLen < 1U) && (u8Addr == 0U))
;;;977                {
;;;978                    I2C_SET_DATA(i2c, data);
;;;979                    u32txLen++;
;;;980                }
;;;981                else
;;;982                {
;;;983                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;984                    u8Xfering = 0U;
;;;985                }
;;;986    
;;;987                break;
;;;988    
;;;989            case 0x38:                                                      /* Arbitration Lost */
;;;990            default:                                                        /* Unknow status */
;;;991                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;992                u8Ctrl = I2C_CTL_SI;
000042  2308              MOVS     r3,#8
;;;993                u8Err = 1U;
;;;994                break;
000044  e00a              B        |L37.92|
                  |L37.70|
000046  4671              MOV      r1,lr                 ;956
000048  0649              LSLS     r1,r1,#25             ;956
00004a  0e09              LSRS     r1,r1,#24             ;956
00004c  6081              STR      r1,[r0,#8]            ;956
00004e  2308              MOVS     r3,#8                 ;957
000050  e015              B        |L37.126|
                  |L37.82|
000052  4661              MOV      r1,r12                ;961
000054  0a0a              LSRS     r2,r1,#8              ;961
000056  6082              STR      r2,[r0,#8]            ;961
000058  e011              B        |L37.126|
                  |L37.90|
00005a  2318              MOVS     r3,#0x18              ;966
                  |L37.92|
00005c  2401              MOVS     r4,#1                 ;967
00005e  e00e              B        |L37.126|
                  |L37.96|
000060  2f00              CMP      r7,#0                 ;971
000062  d004              BEQ      |L37.110|
000064  4661              MOV      r1,r12                ;973
000066  b2c9              UXTB     r1,r1                 ;973
000068  6081              STR      r1,[r0,#8]            ;973
00006a  2700              MOVS     r7,#0                 ;974
00006c  e007              B        |L37.126|
                  |L37.110|
00006e  2e00              CMP      r6,#0                 ;976
000070  d002              BEQ      |L37.120|
000072  2318              MOVS     r3,#0x18              ;983
000074  2500              MOVS     r5,#0                 ;984
000076  e002              B        |L37.126|
                  |L37.120|
000078  9903              LDR      r1,[sp,#0xc]          ;978
00007a  6081              STR      r1,[r0,#8]            ;978
00007c  2601              MOVS     r6,#1                 ;979
                  |L37.126|
;;;995            }
;;;996    
;;;997            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                               /* Write controlbit to I2C_CTL register */
00007e  6801              LDR      r1,[r0,#0]
000080  223c              MOVS     r2,#0x3c
000082  4391              BICS     r1,r1,r2
000084  460a              MOV      r2,r1
000086  431a              ORRS     r2,r2,r3
000088  6002              STR      r2,[r0,#0]
00008a  2d00              CMP      r5,#0                 ;949
00008c  d001              BEQ      |L37.146|
00008e  2c00              CMP      r4,#0                 ;949
000090  d0c2              BEQ      |L37.24|
                  |L37.146|
000092  4620              MOV      r0,r4                 ;949
;;;998        }
;;;999    
;;;1000       return (u8Err | u8Xfering);                                         /* return (Success)/(Fail) status */
000094  4328              ORRS     r0,r0,r5
;;;1001   }
000096  b004              ADD      sp,sp,#0x10
000098  bdf0              POP      {r4-r7,pc}
;;;1002   
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;736    
;;;737    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;738    {
000002  469e              MOV      lr,r3
;;;739        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  4613              MOV      r3,r2                 ;738
000008  2600              MOVS     r6,#0
;;;740        uint32_t u32txLen = 0U;
;;;741    
;;;742        I2C_START(i2c);                                        /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;738
00000e  4634              MOV      r4,r6                 ;739
000010  4635              MOV      r5,r6                 ;740
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;743    
;;;744        while (u8Xfering && (u8Err == 0U))
;;;745        {
;;;746            I2C_WAIT_READY(i2c) {}
;;;747    
;;;748            switch (I2C_GET_STATUS(i2c))
;;;749            {
;;;750            case 0x08:
;;;751                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Write SLA+W to Register I2CDAT */
;;;752                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;753                break;
;;;754    
;;;755            case 0x18:                                         /* Slave Address ACK */
;;;756            case 0x28:
;;;757                if (u32txLen < u32wLen)
;;;758                    I2C_SET_DATA(i2c, data[u32txLen++]);       /* Write Data to I2CDAT */
;;;759                else
;;;760                {
;;;761                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;762                    u8Xfering = 0U;
;;;763                }
;;;764    
;;;765                break;
;;;766    
;;;767            case 0x20:                                         /* Slave Address NACK */
;;;768            case 0x30:                                         /* Master transmit data NACK */
;;;769                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;770                u8Err = 1U;
;;;771                break;
;;;772    
;;;773            case 0x38:                                         /* Arbitration Lost */
;;;774            default:                                           /* Unknow status */
;;;775                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L38.26|
00001a  6801              LDR      r1,[r0,#0]            ;746
00001c  0709              LSLS     r1,r1,#28             ;746
00001e  d5fc              BPL      |L38.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;748
000022  2920              CMP      r1,#0x20              ;748
000024  d01e              BEQ      |L38.100|
000026  dc04              BGT      |L38.50|
000028  2908              CMP      r1,#8                 ;748
00002a  d00c              BEQ      |L38.70|
00002c  2918              CMP      r1,#0x18              ;748
00002e  d104              BNE      |L38.58|
000030  e00f              B        |L38.82|
                  |L38.50|
000032  2928              CMP      r1,#0x28              ;748
000034  d00d              BEQ      |L38.82|
000036  2930              CMP      r1,#0x30              ;748
000038  d014              BEQ      |L38.100|
                  |L38.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;776                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;777                u8Err = 1U;
;;;778                break;
000044  e00f              B        |L38.102|
                  |L38.70|
000046  4661              MOV      r1,r12                ;751
000048  064c              LSLS     r4,r1,#25             ;751
00004a  0e24              LSRS     r4,r4,#24             ;751
00004c  6084              STR      r4,[r0,#8]            ;751
00004e  2408              MOVS     r4,#8                 ;752
000050  e00a              B        |L38.104|
                  |L38.82|
000052  4575              CMP      r5,lr                 ;757
000054  d203              BCS      |L38.94|
000056  5d59              LDRB     r1,[r3,r5]            ;758
000058  6081              STR      r1,[r0,#8]            ;758
00005a  1c6d              ADDS     r5,r5,#1              ;758
00005c  e004              B        |L38.104|
                  |L38.94|
00005e  2418              MOVS     r4,#0x18              ;761
000060  2700              MOVS     r7,#0                 ;762
000062  e001              B        |L38.104|
                  |L38.100|
000064  2418              MOVS     r4,#0x18              ;769
                  |L38.102|
000066  2601              MOVS     r6,#1                 ;770
                  |L38.104|
;;;779            }
;;;780    
;;;781            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
000068  6801              LDR      r1,[r0,#0]
00006a  4391              BICS     r1,r1,r2
00006c  4321              ORRS     r1,r1,r4
00006e  6001              STR      r1,[r0,#0]
000070  2f00              CMP      r7,#0                 ;744
000072  d001              BEQ      |L38.120|
000074  2e00              CMP      r6,#0                 ;744
000076  d0d0              BEQ      |L38.26|
                  |L38.120|
;;;782        }
;;;783    
;;;784        return u32txLen;                                       /* Return bytes length that have been transmitted */
000078  4628              MOV      r0,r5
;;;785    }
00007a  bdf0              POP      {r4-r7,pc}
;;;786    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;873    
;;;874    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;875    {
000002  469e              MOV      lr,r3
;;;876        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  460b              MOV      r3,r1                 ;875
000008  2600              MOVS     r6,#0
;;;877        uint32_t u32txLen = 0U;
;;;878    
;;;879        I2C_START(i2c);                                           /* Send START */
00000a  6801              LDR      r1,[r0,#0]
00000c  4694              MOV      r12,r2                ;875
00000e  4634              MOV      r4,r6                 ;876
000010  4635              MOV      r5,r6                 ;877
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;880    
;;;881        while (u8Xfering && (u8Err == 0U))
;;;882        {
;;;883            I2C_WAIT_READY(i2c) {}
;;;884    
;;;885            switch (I2C_GET_STATUS(i2c))
;;;886            {
;;;887            case 0x08:
;;;888                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
;;;889                u8Ctrl = I2C_CTL_SI;
;;;890                break;
;;;891    
;;;892            case 0x18:                                           /* Slave Address ACK */
;;;893                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;894                break;
;;;895    
;;;896            case 0x20:                                           /* Slave Address NACK */
;;;897            case 0x30:                                           /* Master transmit data NACK */
;;;898                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;899                u8Err = 1U;
;;;900                break;
;;;901    
;;;902            case 0x28:
;;;903                if (u32txLen < u32wLen)
;;;904                    I2C_SET_DATA(i2c, data[u32txLen++]);
;;;905                else
;;;906                {
;;;907                    u8Ctrl = I2C_CTL_STO_SI;                     /* Clear SI and send STOP */
;;;908                    u8Xfering = 0U;
;;;909                }
;;;910    
;;;911                break;
;;;912    
;;;913            case 0x38:                                           /* Arbitration Lost */
;;;914            default:                                             /* Unknow status */
;;;915                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L39.26|
00001a  6801              LDR      r1,[r0,#0]            ;883
00001c  0709              LSLS     r1,r1,#28             ;883
00001e  d5fc              BPL      |L39.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;885
000022  2920              CMP      r1,#0x20              ;885
000024  d017              BEQ      |L39.86|
000026  dc04              BGT      |L39.50|
000028  2908              CMP      r1,#8                 ;885
00002a  d00c              BEQ      |L39.70|
00002c  2918              CMP      r1,#0x18              ;885
00002e  d104              BNE      |L39.58|
000030  e00e              B        |L39.80|
                  |L39.50|
000032  2928              CMP      r1,#0x28              ;885
000034  d012              BEQ      |L39.92|
000036  2930              CMP      r1,#0x30              ;885
000038  d00d              BEQ      |L39.86|
                  |L39.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;916                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;917                u8Err = 1U;
;;;918                break;
000044  e008              B        |L39.88|
                  |L39.70|
000046  065c              LSLS     r4,r3,#25             ;888
000048  0e24              LSRS     r4,r4,#24             ;888
00004a  6084              STR      r4,[r0,#8]            ;888
00004c  2408              MOVS     r4,#8                 ;889
00004e  e00f              B        |L39.112|
                  |L39.80|
000050  4661              MOV      r1,r12                ;893
000052  6081              STR      r1,[r0,#8]            ;893
000054  e00c              B        |L39.112|
                  |L39.86|
000056  2418              MOVS     r4,#0x18              ;898
                  |L39.88|
000058  2601              MOVS     r6,#1                 ;899
00005a  e009              B        |L39.112|
                  |L39.92|
00005c  9905              LDR      r1,[sp,#0x14]         ;903
00005e  428d              CMP      r5,r1                 ;903
000060  d204              BCS      |L39.108|
000062  4671              MOV      r1,lr                 ;904
000064  5d49              LDRB     r1,[r1,r5]            ;904
000066  6081              STR      r1,[r0,#8]            ;904
000068  1c6d              ADDS     r5,r5,#1              ;904
00006a  e001              B        |L39.112|
                  |L39.108|
00006c  2418              MOVS     r4,#0x18              ;907
00006e  2700              MOVS     r7,#0                 ;908
                  |L39.112|
;;;919            }
;;;920    
;;;921            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000070  6801              LDR      r1,[r0,#0]
000072  4391              BICS     r1,r1,r2
000074  4321              ORRS     r1,r1,r4
000076  6001              STR      r1,[r0,#0]
000078  2f00              CMP      r7,#0                 ;881
00007a  d001              BEQ      |L39.128|
00007c  2e00              CMP      r6,#0                 ;881
00007e  d0cc              BEQ      |L39.26|
                  |L39.128|
;;;922        }
;;;923    
;;;924        return u32txLen;                                         /* Return bytes length that have been transmitted */
000080  4628              MOV      r0,r5
;;;925    }
000082  bdf0              POP      {r4-r7,pc}
;;;926    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;1018   
;;;1019   uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data[], uint32_t u32wLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1020   {
;;;1021       uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2701              MOVS     r7,#1
000004  468e              MOV      lr,r1                 ;1020
000006  2500              MOVS     r5,#0
;;;1022       uint32_t u32txLen = 0U;
;;;1023   
;;;1024       I2C_START(i2c);                                                     /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;1020
00000c  463e              MOV      r6,r7                 ;1021
00000e  462b              MOV      r3,r5                 ;1021
000010  462c              MOV      r4,r5                 ;1022
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L40.24|
;;;1025   
;;;1026       while (u8Xfering && (u8Err == 0U))
;;;1027       {
;;;1028           I2C_WAIT_READY(i2c) {}
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L40.24|
;;;1029   
;;;1030           switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d01a              BEQ      |L40.90|
000024  dc04              BGT      |L40.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L40.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L40.56|
00002e  e010              B        |L40.82|
                  |L40.48|
000030  2a28              CMP      r2,#0x28
000032  d015              BEQ      |L40.96|
000034  2a30              CMP      r2,#0x30
000036  d010              BEQ      |L40.90|
                  |L40.56|
;;;1031           {
;;;1032           case 0x08:
;;;1033               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));               /* Write SLA+W to Register I2CDAT */
;;;1034               u8Ctrl = I2C_CTL_SI;                                        /* Clear SI */
;;;1035               break;
;;;1036   
;;;1037           case 0x18:                                                      /* Slave Address ACK */
;;;1038               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte address of register */
;;;1039               break;
;;;1040   
;;;1041           case 0x20:                                                      /* Slave Address NACK */
;;;1042           case 0x30:                                                      /* Master transmit data NACK */
;;;1043               u8Ctrl = I2C_CTL_STO_SI;                                    /* Clear SI and send STOP */
;;;1044               u8Err = 1U;
;;;1045               break;
;;;1046   
;;;1047           case 0x28:
;;;1048               if (u8Addr)
;;;1049               {
;;;1050                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));       /* Write Lo byte address of register */
;;;1051                   u8Addr = 0U;
;;;1052               }
;;;1053               else if ((u32txLen < u32wLen) && (u8Addr == 0U))
;;;1054                   I2C_SET_DATA(i2c, data[u32txLen++]);                    /* Write data to Register I2CDAT*/
;;;1055               else
;;;1056               {
;;;1057                   u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;1058                   u8Xfering = 0U;
;;;1059               }
;;;1060   
;;;1061               break;
;;;1062   
;;;1063           case 0x38:                                                      /* Arbitration Lost */
;;;1064           default:                                                        /* Unknow status */
;;;1065               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;1066               u8Ctrl = I2C_CTL_SI;
000042  2308              MOVS     r3,#8
;;;1067               u8Err = 1U;
;;;1068               break;
000044  e00a              B        |L40.92|
                  |L40.70|
000046  4671              MOV      r1,lr                 ;1033
000048  0649              LSLS     r1,r1,#25             ;1033
00004a  0e09              LSRS     r1,r1,#24             ;1033
00004c  6081              STR      r1,[r0,#8]            ;1033
00004e  2308              MOVS     r3,#8                 ;1034
000050  e017              B        |L40.130|
                  |L40.82|
000052  4661              MOV      r1,r12                ;1038
000054  0a0a              LSRS     r2,r1,#8              ;1038
000056  6082              STR      r2,[r0,#8]            ;1038
000058  e013              B        |L40.130|
                  |L40.90|
00005a  2318              MOVS     r3,#0x18              ;1043
                  |L40.92|
00005c  2501              MOVS     r5,#1                 ;1044
00005e  e010              B        |L40.130|
                  |L40.96|
000060  2e00              CMP      r6,#0                 ;1048
000062  d004              BEQ      |L40.110|
000064  4661              MOV      r1,r12                ;1050
000066  b2c9              UXTB     r1,r1                 ;1050
000068  6081              STR      r1,[r0,#8]            ;1050
00006a  2600              MOVS     r6,#0                 ;1051
00006c  e009              B        |L40.130|
                  |L40.110|
00006e  9a09              LDR      r2,[sp,#0x24]         ;1053
000070  4294              CMP      r4,r2                 ;1053
000072  d204              BCS      |L40.126|
000074  9a03              LDR      r2,[sp,#0xc]          ;1054
000076  5d12              LDRB     r2,[r2,r4]            ;1054
000078  6082              STR      r2,[r0,#8]            ;1054
00007a  1c64              ADDS     r4,r4,#1              ;1054
00007c  e001              B        |L40.130|
                  |L40.126|
00007e  2318              MOVS     r3,#0x18              ;1057
000080  2700              MOVS     r7,#0                 ;1058
                  |L40.130|
;;;1069           }
;;;1070   
;;;1071           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                               /* Write controlbit to I2C_CTL register */
000082  6801              LDR      r1,[r0,#0]
000084  223c              MOVS     r2,#0x3c
000086  4391              BICS     r1,r1,r2
000088  460a              MOV      r2,r1
00008a  431a              ORRS     r2,r2,r3
00008c  6002              STR      r2,[r0,#0]
00008e  2f00              CMP      r7,#0                 ;1026
000090  d001              BEQ      |L40.150|
000092  2d00              CMP      r5,#0                 ;1026
000094  d0c0              BEQ      |L40.24|
                  |L40.150|
;;;1072       }
;;;1073   
;;;1074       return u32txLen;                                                    /* Return bytes length that have been transmitted */
000096  4620              MOV      r0,r4
;;;1075   }
000098  b004              ADD      sp,sp,#0x10
00009a  bdf0              POP      {r4-r7,pc}
;;;1076   
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L247.16|
00000e  461d              MOV      r5,r3
                  |L247.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 402
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
