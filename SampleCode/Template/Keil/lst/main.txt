; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\Kalman_Filter -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;301    
;;;302    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;303    {
;;;304        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L1.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;305    }
00000c  bd10              POP      {r4,pc}
;;;306    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40004040

                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;189    
;;;190    void PDMA_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;191    {
;;;192        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  4c22              LDR      r4,|L2.140|
000004  69e0              LDR      r0,[r4,#0x1c]
;;;193    
;;;194        if(status & PDMA_INTSTS_REQTOF1_Msk)	//(1 << (PDMA_INTSTS_REQTOF1_Pos + UART_RX_PDMA_CH) /* Request Time-out */
000006  0581              LSLS     r1,r0,#22
000008  d524              BPL      |L2.84|
;;;195        {
;;;196    		PDMA_SetTimeOut(PDMA,1, 0, 0);
00000a  4d21              LDR      r5,|L2.144|
00000c  2300              MOVS     r3,#0
00000e  461a              MOV      r2,r3
000010  2101              MOVS     r1,#1
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       PDMA_SetTimeOut
;;;197    	
;;;198            /* Clear PDMA timeout interrupt flag */
;;;199            PDMA_CLR_TMOUT_FLAG(PDMA, 0);
000018  15a0              ASRS     r0,r4,#22
00001a  61e0              STR      r0,[r4,#0x1c]
;;;200    
;;;201    		PDMA_SetTimeOut(PDMA,0, TRUE, PDMATIMEOUT(1));
00001c  f7fffffe          BL       CLK_GetCPUFreq
000020  217d              MOVS     r1,#0x7d
000022  0bc0              LSRS     r0,r0,#15
000024  00c9              LSLS     r1,r1,#3
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  4603              MOV      r3,r0
00002c  2201              MOVS     r2,#1
00002e  2100              MOVS     r1,#0
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       PDMA_SetTimeOut
;;;202            /* Disable and enable timeout function to restart the timeout counter */
;;;203    		PDMA_DisableTimeout(PDMA,(1 << 0) );
000036  2101              MOVS     r1,#1
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       PDMA_DisableTimeout
;;;204    		PDMA_EnableTimeout(PDMA,(1 << 0) );
00003e  2101              MOVS     r1,#1
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       PDMA_EnableTimeout
;;;205    		
;;;206            /* Set transfer count and trigger again */
;;;207            PDMA_SetTransferCnt(PDMA, 0, PDMA_WIDTH_32, dPDMA_TEST_LENGTH);
000046  2302              MOVS     r3,#2
000048  031a              LSLS     r2,r3,#12
00004a  2100              MOVS     r1,#0
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       PDMA_SetTransferCnt
;;;208            /* Get the latest status for SPI PDMA again */
;;;209            status = PDMA_GET_INT_STATUS(PDMA);
000052  69e0              LDR      r0,[r4,#0x1c]
                  |L2.84|
000054  2502              MOVS     r5,#2                 ;207
;;;210        }
;;;211    
;;;212    
;;;213        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000056  07c1              LSLS     r1,r0,#31
000058  2900              CMP      r1,#0
00005a  d007              BEQ      |L2.108|
;;;214        {
;;;215            /* Check if channel 1 has abort error */
;;;216            if (PDMA_GET_ABORT_STS(PDMA) & PDMA_ABTSTS_ABTIF1_Msk)
00005c  6a20              LDR      r0,[r4,#0x20]
00005e  0780              LSLS     r0,r0,#30
000060  d502              BPL      |L2.104|
;;;217            {
;;;218    			//abort
;;;219    			printf("abort\r\n");
000062  a00c              ADR      r0,|L2.148|
000064  f7fffffe          BL       __2printf
                  |L2.104|
;;;220            }
;;;221    
;;;222            /* Clear abort flag of channel 1 */
;;;223            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_ABTSTS_ABTIF1_Msk);
000068  6225              STR      r5,[r4,#0x20]
;;;224        }
;;;225        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;226        {
;;;227            /* Check transmission of channel 1 has been transfer done */
;;;228            if (PDMA_GET_TD_STS(PDMA) & PDMA_TDSTS_TDIF1_Msk)
;;;229            {
;;;230    			//done
;;;231    			TIMER_ClearCaptureIntFlag(TIMER1);
;;;232    //			TIMER_Stop(TIMER1);
;;;233    			
;;;234    			PDMA_TimerCapture_Process();
;;;235    
;;;236            }
;;;237    
;;;238            /* Clear transfer done flag of channel 1 */
;;;239            PDMA_CLR_TD_FLAG(PDMA, PDMA_TDSTS_TDIF1_Msk);
;;;240        }
;;;241        else
;;;242            printf("unknown interrupt !!\n");
;;;243    }
00006a  bd70              POP      {r4-r6,pc}
                  |L2.108|
00006c  0780              LSLS     r0,r0,#30             ;225
00006e  d509              BPL      |L2.132|
000070  6a60              LDR      r0,[r4,#0x24]         ;228
000072  0780              LSLS     r0,r0,#30             ;228
000074  d504              BPL      |L2.128|
000076  4909              LDR      r1,|L2.156|
000078  2001              MOVS     r0,#1                 ;228
00007a  6188              STR      r0,[r1,#0x18]         ;228
00007c  f7fffffe          BL       PDMA_TimerCapture_Process
                  |L2.128|
000080  6265              STR      r5,[r4,#0x24]         ;239
000082  bd70              POP      {r4-r6,pc}
                  |L2.132|
000084  a006              ADR      r0,|L2.160|
000086  f7fffffe          BL       __2printf
00008a  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  |L2.140|
                          DCD      0x40008400
                  |L2.144|
                          DCD      0x40008000
                  |L2.148|
000094  61626f72          DCB      "abort\r\n",0
000098  740d0a00
                  |L2.156|
                          DCD      0x40050020
                  |L2.160|
0000a0  756e6b6e          DCB      "unknown interrupt !!\n",0
0000a4  6f776e20
0000a8  696e7465
0000ac  72727570
0000b0  74202121
0000b4  0a00    
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.PDMA_TimerCapture_Init||, CODE, READONLY, ALIGN=2

                  PDMA_TimerCapture_Init PROC
;;;121    
;;;122    void PDMA_TimerCapture_Init(void)	//PA10 : TM1_EXT 
000000  b57c              PUSH     {r2-r6,lr}
;;;123    {
;;;124        /* Enable Timer1 external capture function */
;;;125        TIMER_Open(TIMER1, TIMER_CONTINUOUS_MODE, 1);
000002  4c2f              LDR      r4,|L3.192|
000004  2103              MOVS     r1,#3
000006  2201              MOVS     r2,#1
000008  06c9              LSLS     r1,r1,#27
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       TIMER_Open
;;;126        TIMER_SET_PRESCALE_VALUE(TIMER1, TIMER_PSC);
000010  482b              LDR      r0,|L3.192|
000012  3820              SUBS     r0,r0,#0x20
000014  6a01              LDR      r1,[r0,#0x20]
000016  22ff              MOVS     r2,#0xff
000018  4311              ORRS     r1,r1,r2
00001a  6201              STR      r1,[r0,#0x20]
;;;127        TIMER_SET_CMP_VALUE(TIMER1, 0xFFFFFF);
00001c  4929              LDR      r1,|L3.196|
00001e  6241              STR      r1,[r0,#0x24]
;;;128        TIMER_EnableCapture(TIMER1, TIMER_CAPTURE_FREE_COUNTING_MODE, TIMER_CAPTURE_FALLING_EDGE);
000020  2200              MOVS     r2,#0
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TIMER_EnableCapture
;;;129        TIMER_SetTriggerSource(TIMER1, TIMER_TRGSRC_CAPTURE_EVENT);
00002a  2101              MOVS     r1,#1
00002c  0489              LSLS     r1,r1,#18
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       TIMER_SetTriggerSource
;;;130        TIMER_SetTriggerTarget(TIMER1, TIMER_TRG_TO_PDMA);
000034  15a1              ASRS     r1,r4,#22
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       TIMER_SetTriggerTarget
;;;131    
;;;132        /* Open Channel 1 */
;;;133        PDMA_Open(PDMA, 1 << PDMAchannel_TIMER_EXT);
00003c  4d22              LDR      r5,|L3.200|
00003e  2102              MOVS     r1,#2
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       PDMA_Open
;;;134        /* Transfer count is PDMA_TEST_LENGTH, transfer width is 8 bits(one byte) */
;;;135        PDMA_SetTransferCnt(PDMA, PDMAchannel_TIMER_EXT, PDMA_WIDTH_32, dPDMA_TEST_LENGTH);
000046  2302              MOVS     r3,#2
000048  031a              LSLS     r2,r3,#12
00004a  2101              MOVS     r1,#1
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       PDMA_SetTransferCnt
;;;136        /* Set source address is au8SrcArray, Source increment size is 8 bits(one byte), destination address is PA->DOUT (no increment)*/
;;;137        PDMA_SetTransferAddr(PDMA, PDMAchannel_TIMER_EXT, (uint32_t) &(TIMER1->CAP), PDMA_SAR_FIX, (uint32_t)g_au32CAPValue, PDMA_DAR_INC);
000052  481e              LDR      r0,|L3.204|
000054  4a1a              LDR      r2,|L3.192|
000056  2600              MOVS     r6,#0
000058  2303              MOVS     r3,#3
00005a  9000              STR      r0,[sp,#0]
00005c  021b              LSLS     r3,r3,#8
00005e  3210              ADDS     r2,r2,#0x10
000060  2101              MOVS     r1,#1
000062  9601              STR      r6,[sp,#4]
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       PDMA_SetTransferAddr
;;;138        /* Request source is timer 1 */
;;;139        PDMA_SetTransferMode(PDMA, PDMAchannel_TIMER_EXT, PDMA_TMR1, FALSE,(uint32_t) NULL);
00006a  2300              MOVS     r3,#0
00006c  2221              MOVS     r2,#0x21
00006e  2101              MOVS     r1,#1
000070  4628              MOV      r0,r5
000072  9600              STR      r6,[sp,#0]
000074  f7fffffe          BL       PDMA_SetTransferMode
;;;140        /* Transfer type is burst transfer and burst size is 4 */
;;;141        PDMA_SetBurstType(PDMA, PDMAchannel_TIMER_EXT, PDMA_REQ_SINGLE,(uint32_t) NULL);
000078  2300              MOVS     r3,#0
00007a  2204              MOVS     r2,#4
00007c  2101              MOVS     r1,#1
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       PDMA_SetBurstType
;;;142    
;;;143    	PDMA_SetTimeOut(PDMA,PDMAchannel_TIMER_EXT, TRUE, PDMATIMEOUT(1));
000084  f7fffffe          BL       CLK_GetCPUFreq
000088  217d              MOVS     r1,#0x7d
00008a  0bc0              LSRS     r0,r0,#15
00008c  00c9              LSLS     r1,r1,#3
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  4603              MOV      r3,r0
000094  2201              MOVS     r2,#1
000096  4611              MOV      r1,r2
000098  4628              MOV      r0,r5
00009a  f7fffffe          BL       PDMA_SetTimeOut
;;;144    	PDMA_EnableTimeout(PDMA,(1 << PDMAchannel_TIMER_EXT));
00009e  2102              MOVS     r1,#2
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       PDMA_EnableTimeout
;;;145    
;;;146        /* Enable interrupt */
;;;147        PDMA_EnableInt(PDMA, PDMAchannel_TIMER_EXT, PDMA_INT_TRANS_DONE);
0000a6  2200              MOVS     r2,#0
0000a8  2101              MOVS     r1,#1
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       PDMA_EnableInt
0000b0  4907              LDR      r1,|L3.208|
0000b2  0560              LSLS     r0,r4,#21
0000b4  6008              STR      r0,[r1,#0]
0000b6  6820              LDR      r0,[r4,#0]
0000b8  0589              LSLS     r1,r1,#22
0000ba  4308              ORRS     r0,r0,r1
0000bc  6020              STR      r0,[r4,#0]
;;;148        /* Enable NVIC for PDMA */
;;;149        NVIC_EnableIRQ(PDMA_IRQn);
;;;150    
;;;151        TIMER_Start(TIMER1);
;;;152    	
;;;153    }
0000be  bd7c              POP      {r2-r6,pc}
;;;154    
                          ENDP

                  |L3.192|
                          DCD      0x40050020
                  |L3.196|
                          DCD      0x00ffffff
                  |L3.200|
                          DCD      0x40008000
                  |L3.204|
                          DCD      ||.data||+0x10
                  |L3.208|
                          DCD      0xe000e100

                          AREA ||i.PDMA_TimerCapture_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_f
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_fp_dec
                  PDMA_TimerCapture_Process PROC
;;;155    
;;;156    void PDMA_TimerCapture_Process(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;157    {
;;;158        uint32_t u32InitCount = 0;
;;;159        volatile uint32_t u32CAPDiff = 0;
000002  2000              MOVS     r0,#0
000004  b085              SUB      sp,sp,#0x14           ;157
;;;160        volatile uint32_t res = 0;	
000006  9000              STR      r0,[sp,#0]
;;;161    	
;;;162    	#if defined (USE_INT)
;;;163        uint32_t Freq = 0;
;;;164    	#elif defined (USE_FLOAT)
;;;165        double Freq = 0;
;;;166    	#endif
;;;167    	
;;;168        for(u32InitCount = 1; u32InitCount < dPDMA_TEST_LENGTH; u32InitCount++)
000008  2401              MOVS     r4,#1
00000a  9001              STR      r0,[sp,#4]
                  |L4.12|
;;;169        {
;;;170            u32CAPDiff = g_au32CAPValue[u32InitCount] - g_au32CAPValue[u32InitCount - 1];
00000c  4815              LDR      r0,|L4.100|
00000e  00a6              LSLS     r6,r4,#2
000010  5981              LDR      r1,[r0,r6]
000012  1835              ADDS     r5,r6,r0
000014  3d80              SUBS     r5,r5,#0x80
000016  6fea              LDR      r2,[r5,#0x7c]
000018  1a89              SUBS     r1,r1,r2
;;;171    		res = (SystemCoreClock / (TIMER_PSC + 1));
00001a  9100              STR      r1,[sp,#0]
00001c  4912              LDR      r1,|L4.104|
00001e  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000020  0a09              LSRS     r1,r1,#8
;;;172    			
;;;173    		if (g_au32CAPValue[u32InitCount] > g_au32CAPValue[u32InitCount - 1])
000022  9101              STR      r1,[sp,#4]
000024  5980              LDR      r0,[r0,r6]
000026  6fe9              LDR      r1,[r5,#0x7c]
000028  4288              CMP      r0,r1
00002a  d914              BLS      |L4.86|
;;;174    		{
;;;175    			#if defined (USE_INT)
;;;176    			Freq = (res/u32CAPDiff);			
;;;177    			
;;;178    			printf("%8d , %8d , clock : %6d , Diff: %9d. Freq: %6d Hz\r\n",g_au32CAPValue[u32InitCount], g_au32CAPValue[u32InitCount - 1],res,u32CAPDiff, Freq);
;;;179    			#elif defined (USE_FLOAT) 
;;;180    			Freq = ((double )res/(double )u32CAPDiff);
00002c  9800              LDR      r0,[sp,#0]
00002e  f7fffffe          BL       __aeabi_ui2d
000032  4607              MOV      r7,r0
000034  9102              STR      r1,[sp,#8]
000036  9801              LDR      r0,[sp,#4]
000038  f7fffffe          BL       __aeabi_ui2d
00003c  463a              MOV      r2,r7
00003e  9b02              LDR      r3,[sp,#8]
000040  f7fffffe          BL       __aeabi_ddiv
;;;181    			
;;;182    			printf("%8d , %8d , clock : %6d , Diff: %9d. Freq: %.2f Hz\r\n",g_au32CAPValue[u32InitCount], g_au32CAPValue[u32InitCount - 1],res,u32CAPDiff, Freq);
000044  9002              STR      r0,[sp,#8]
000046  9103              STR      r1,[sp,#0xc]
000048  4806              LDR      r0,|L4.100|
00004a  6fea              LDR      r2,[r5,#0x7c]
00004c  5981              LDR      r1,[r0,r6]
00004e  a007              ADR      r0,|L4.108|
000050  9b01              LDR      r3,[sp,#4]
000052  f7fffffe          BL       __2printf
                  |L4.86|
000056  1c64              ADDS     r4,r4,#1
000058  2c02              CMP      r4,#2                 ;168
00005a  d3d7              BCC      |L4.12|
;;;183    			#endif
;;;184    		}
;;;185        }
;;;186    
;;;187    	PDMA_TimerCapture_Start();//PDMA_TimerCapture_Init();
00005c  f7fffffe          BL       PDMA_TimerCapture_Start
;;;188    }
000060  b005              ADD      sp,sp,#0x14
000062  bdf0              POP      {r4-r7,pc}
;;;189    
                          ENDP

                  |L4.100|
                          DCD      ||.data||+0x10
                  |L4.104|
                          DCD      SystemCoreClock
                  |L4.108|
00006c  25386420          DCB      "%8d , %8d , clock : %6d , Diff: %9d. Freq: %.2f Hz\r\n",0
000070  2c202538
000074  64202c20
000078  636c6f63
00007c  6b203a20
000080  25366420
000084  2c204469
000088  66663a20
00008c  2539642e
000090  20467265
000094  713a2025
000098  2e326620
00009c  487a0d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i.PDMA_TimerCapture_Start||, CODE, READONLY, ALIGN=2

                  PDMA_TimerCapture_Start PROC
;;;102    
;;;103    void PDMA_TimerCapture_Start(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;104    {
;;;105        /* Transfer count is PDMA_TEST_LENGTH, transfer width is 8 bits(one byte) */
;;;106        PDMA_SetTransferCnt(PDMA, PDMAchannel_TIMER_EXT, PDMA_WIDTH_32, dPDMA_TEST_LENGTH);
000002  4d10              LDR      r5,|L5.68|
000004  2302              MOVS     r3,#2
000006  031a              LSLS     r2,r3,#12
000008  2101              MOVS     r1,#1
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       PDMA_SetTransferCnt
;;;107        /* Set source address is au8SrcArray, Source increment size is 8 bits(one byte), destination address is PA->DOUT (no increment)*/
;;;108        PDMA_SetTransferAddr(PDMA, PDMAchannel_TIMER_EXT, (uint32_t) &(TIMER1->CAP), PDMA_SAR_FIX, (uint32_t)g_au32CAPValue, PDMA_DAR_INC);
000010  490d              LDR      r1,|L5.72|
000012  2400              MOVS     r4,#0
000014  2303              MOVS     r3,#3
000016  9100              STR      r1,[sp,#0]
000018  021b              LSLS     r3,r3,#8
00001a  4a0c              LDR      r2,|L5.76|
00001c  9401              STR      r4,[sp,#4]
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       PDMA_SetTransferAddr
;;;109        /* Request source is timer 1 */
;;;110        PDMA_SetTransferMode(PDMA, PDMAchannel_TIMER_EXT, PDMA_TMR1, FALSE,(uint32_t) NULL);
000026  2300              MOVS     r3,#0
000028  2221              MOVS     r2,#0x21
00002a  2101              MOVS     r1,#1
00002c  4628              MOV      r0,r5
00002e  9400              STR      r4,[sp,#0]
000030  f7fffffe          BL       PDMA_SetTransferMode
;;;111        /* Transfer type is burst transfer and burst size is 4 */
;;;112        PDMA_SetBurstType(PDMA, PDMAchannel_TIMER_EXT, PDMA_REQ_SINGLE,(uint32_t) NULL);
000034  2300              MOVS     r3,#0
000036  2204              MOVS     r2,#4
000038  2101              MOVS     r1,#1
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       PDMA_SetBurstType
;;;113    }
000040  bd7c              POP      {r2-r6,pc}
;;;114    
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      0x40008000
                  |L5.72|
                          DCD      ||.data||+0x10
                  |L5.76|
                          DCD      0x40050030

                          AREA ||i.PWM0_Init||, CODE, READONLY, ALIGN=2

                  PWM0_Init PROC
;;;261    
;;;262    void PWM0_Init(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;263    {
;;;264        /*
;;;265          Configure PWM0 channel 0 init period and duty(down counter type).
;;;266          Period is PLL / (prescaler * (CNR + 1))
;;;267          Duty ratio = CMR / (CNR + 1)
;;;268          Period = 48 MHz / (1 * (199 + 1)) = 240000 Hz
;;;269          Duty ratio = 100 / (199 + 1) = 50%
;;;270        */
;;;271    
;;;272    	#if 0
;;;273        /* Set PWM0 timer clock prescaler */
;;;274        PWM_SET_PRESCALER(PWM0, PWM_CH, PWM_PSC - 1);
;;;275    
;;;276        /* Set up counter type */
;;;277        PWM0->CTL1 &= ~PWM_CTL1_CNTTYPE0_Msk;
;;;278    
;;;279        /* Set PWM0 timer period */
;;;280        PWM_SET_CNR(PWM0, PWM_CH, PWM_CNR);
;;;281    
;;;282        /* Set PWM0 timer duty */
;;;283        PWM_SET_CMR(PWM0, PWM_CH, PWM_CMR);	
;;;284    
;;;285    	#else
;;;286    	PWM_ConfigOutputChannel(PWM0, PWM_CH, PWM_FREQ, PWM_DUTY);
000002  4c1c              LDR      r4,|L6.116|
000004  2332              MOVS     r3,#0x32
000006  2264              MOVS     r2,#0x64
000008  2100              MOVS     r1,#0
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       PWM_ConfigOutputChannel
;;;287    	#endif
;;;288    
;;;289        /* Enable output of PWM0 channel 0 */
;;;290        PWM_EnableOutput(PWM0, PWM_CH_MASK);
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       PWM_EnableOutput
;;;291    
;;;292        /* Set output level at zero, compare up, period(center) and compare down of specified channel */
;;;293        PWM_SET_OUTPUT_LEVEL(PWM0, PWM_CH_MASK, PWM_OUTPUT_NOTHING, PWM_OUTPUT_NOTHING, PWM_OUTPUT_HIGH, PWM_OUTPUT_LOW);
000018  2000              MOVS     r0,#0
00001a  2701              MOVS     r7,#1                 ;290
                  |L6.28|
00001c  4639              MOV      r1,r7                 ;290
00001e  4081              LSLS     r1,r1,r0
000020  07c9              LSLS     r1,r1,#31
000022  d01a              BEQ      |L6.90|
000024  4913              LDR      r1,|L6.116|
000026  3180              ADDS     r1,r1,#0x80
000028  6b0b              LDR      r3,[r1,#0x30]
00002a  2603              MOVS     r6,#3
00002c  0042              LSLS     r2,r0,#1
00002e  4634              MOV      r4,r6
000030  4094              LSLS     r4,r4,r2
000032  43a3              BICS     r3,r3,r4
000034  630b              STR      r3,[r1,#0x30]
000036  6b0d              LDR      r5,[r1,#0x30]
000038  4633              MOV      r3,r6
00003a  3210              ADDS     r2,r2,#0x10
00003c  4093              LSLS     r3,r3,r2
00003e  2602              MOVS     r6,#2
000040  439d              BICS     r5,r5,r3
000042  4096              LSLS     r6,r6,r2
000044  4335              ORRS     r5,r5,r6
000046  630d              STR      r5,[r1,#0x30]
000048  6b4d              LDR      r5,[r1,#0x34]
00004a  43a5              BICS     r5,r5,r4
00004c  634d              STR      r5,[r1,#0x34]
00004e  6b4c              LDR      r4,[r1,#0x34]
000050  439c              BICS     r4,r4,r3
000052  463b              MOV      r3,r7
000054  4093              LSLS     r3,r3,r2
000056  431c              ORRS     r4,r4,r3
000058  634c              STR      r4,[r1,#0x34]
                  |L6.90|
00005a  1c40              ADDS     r0,r0,#1
00005c  2806              CMP      r0,#6
00005e  dbdd              BLT      |L6.28|
;;;294    
;;;295    	PWM_Start(PWM0, PWM_CH_MASK);
000060  2101              MOVS     r1,#1
000062  4804              LDR      r0,|L6.116|
000064  f7fffffe          BL       PWM_Start
;;;296    
;;;297    	set_flag(flag_reverse , ENABLE);
000068  4903              LDR      r1,|L6.120|
00006a  6888              LDR      r0,[r1,#8]  ; BitFlag
00006c  2210              MOVS     r2,#0x10
00006e  4310              ORRS     r0,r0,r2
000070  6088              STR      r0,[r1,#8]  ; BitFlag
;;;298    
;;;299    }
000072  bdf8              POP      {r3-r7,pc}
;;;300    
                          ENDP

                  |L6.116|
                          DCD      0x40058000
                  |L6.120|
                          DCD      ||.data||

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;518    
;;;519    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c2e              LDR      r4,|L7.192|
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L7.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6021              STR      r1,[r4,#0]
00000e  6022              STR      r2,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L7.10|
;;;520    {
;;;521        /* Unlock protected registers */
;;;522        SYS_UnlockReg();
;;;523    
;;;524        /* Enable HIRC clock (Internal RC 48MHz) */
;;;525        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;526    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;527    	
;;;528        /* Wait for HIRC clock ready */
;;;529        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;530    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;531    	
;;;532        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;533        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000022  2100              MOVS     r1,#0
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       CLK_SetHCLK
;;;534    //    CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1));
;;;535    	
;;;536        /* Enable UART0 clock */
;;;537        CLK_EnableModuleClock(UART0_MODULE);
00002a  4d26              LDR      r5,|L7.196|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       CLK_EnableModuleClock
;;;538        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000032  2101              MOVS     r1,#1
000034  2200              MOVS     r2,#0
000036  0689              LSLS     r1,r1,#26
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       CLK_SetModuleClock
;;;539    
;;;540        /* Enable PDMA clock */
;;;541        CLK_EnableModuleClock(PDMA_MODULE);
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       CLK_EnableModuleClock
;;;542    
;;;543        CLK_EnableModuleClock(TMR1_MODULE);
000044  4d20              LDR      r5,|L7.200|
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       CLK_EnableModuleClock
;;;544       	CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_PCLK0, 0);
00004c  2101              MOVS     r1,#1
00004e  2200              MOVS     r2,#0
000050  0349              LSLS     r1,r1,#13
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       CLK_SetModuleClock
;;;545    	
;;;546        CLK_EnableModuleClock(TMR3_MODULE);
000058  4d1c              LDR      r5,|L7.204|
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       CLK_EnableModuleClock
;;;547        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000060  2101              MOVS     r1,#1
000062  2200              MOVS     r2,#0
000064  0549              LSLS     r1,r1,#21
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       CLK_SetModuleClock
;;;548    	
;;;549        CLK_EnableModuleClock(PWM0_MODULE);
00006c  4d18              LDR      r5,|L7.208|
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       CLK_EnableModuleClock
;;;550        CLK_SetModuleClock(PWM0_MODULE, CLK_CLKSEL2_PWM0SEL_PCLK0, 0);
000074  2200              MOVS     r2,#0
000076  2101              MOVS     r1,#1
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       CLK_SetModuleClock
;;;551        /* Reset PWM0 module */
;;;552        SYS_ResetModule(PWM0_RST);
00007e  4815              LDR      r0,|L7.212|
000080  f7fffffe          BL       SYS_ResetModule
;;;553    
;;;554        /* Update System Core Clock */
;;;555        SystemCoreClockUpdate();
000084  f7fffffe          BL       SystemCoreClockUpdate
;;;556    
;;;557        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;558        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000088  06a8              LSLS     r0,r5,#26
00008a  6bc1              LDR      r1,[r0,#0x3c]
00008c  22ff              MOVS     r2,#0xff
00008e  0412              LSLS     r2,r2,#16
000090  4391              BICS     r1,r1,r2
000092  2233              MOVS     r2,#0x33
000094  0452              LSLS     r2,r2,#17
000096  1889              ADDS     r1,r1,r2
000098  63c1              STR      r1,[r0,#0x3c]
;;;559                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;560    
;;;561    
;;;562    	/*----------------------------------------------------*/
;;;563        SYS->GPB_MFPL = (SYS->GPB_MFPL & (~SYS_GPB_MFPL_PB5MFP_Msk)) |
00009a  6b81              LDR      r1,[r0,#0x38]
00009c  220f              MOVS     r2,#0xf
00009e  0512              LSLS     r2,r2,#20
0000a0  4391              BICS     r1,r1,r2
0000a2  220b              MOVS     r2,#0xb
0000a4  0512              LSLS     r2,r2,#20
0000a6  1889              ADDS     r1,r1,r2
0000a8  6381              STR      r1,[r0,#0x38]
;;;564                        SYS_GPB_MFPL_PB5MFP_PWM0_CH0;
;;;565    
;;;566    
;;;567    	/*----------------------------------------------------*/
;;;568        /* Set multi-function pin for Timer1 external capture pin */
;;;569        SYS->GPA_MFPH = (SYS->GPA_MFPH & ~(SYS_GPA_MFPH_PA10MFP_Msk)) \
0000aa  6b41              LDR      r1,[r0,#0x34]
0000ac  220f              MOVS     r2,#0xf
0000ae  0212              LSLS     r2,r2,#8
0000b0  4391              BICS     r1,r1,r2
0000b2  220d              MOVS     r2,#0xd
0000b4  0212              LSLS     r2,r2,#8
0000b6  1889              ADDS     r1,r1,r2
0000b8  6341              STR      r1,[r0,#0x34]
0000ba  2000              MOVS     r0,#0
0000bc  6020              STR      r0,[r4,#0]
;;;570                        | SYS_GPA_MFPH_PA10MFP_TM1_EXT;	
;;;571    
;;;572        /* Lock protected registers */
;;;573        SYS_LockReg();
;;;574    }
0000be  bd70              POP      {r4-r6,pc}
;;;575    
                          ENDP

                  |L7.192|
                          DCD      0x40000100
                  |L7.196|
                          DCD      0x5f803d10
                  |L7.200|
                          DCD      0x5ec00003
                  |L7.204|
                          DCD      0x5f400005
                  |L7.208|
                          DCD      0xa2000010
                  |L7.212|
                          DCD      0x08000010

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;378    
;;;379    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;380    {
;;;381        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L8.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L8.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;382        TIMER_EnableInt(TIMER3);
;;;383        NVIC_EnableIRQ(TMR3_IRQn);	
;;;384        TIMER_Start(TIMER3);
;;;385    }
000028  bd10              POP      {r4,pc}
;;;386    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40051020
                  |L8.48|
                          DCD      0xe000e100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;244    
;;;245    void TMR1_IRQHandler(void)
000000  4802              LDR      r0,|L9.12|
000002  6981              LDR      r1,[r0,#0x18]
;;;246    {
;;;247        if(TIMER_GetCaptureIntFlag(TIMER1) == 1)
000004  2901              CMP      r1,#1
000006  d100              BNE      |L9.10|
000008  6181              STR      r1,[r0,#0x18]         ;246
                  |L9.10|
;;;248        {
;;;249            /* Clear Timer1 capture trigger interrupt flag */
;;;250            TIMER_ClearCaptureIntFlag(TIMER1);
;;;251        }
;;;252    }
00000a  4770              BX       lr
;;;253    
                          ENDP

                  |L9.12|
                          DCD      0x40050020

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;316    
;;;317    void TMR3_IRQHandler(void)
000000  4812              LDR      r0,|L10.76|
000002  6881              LDR      r1,[r0,#8]
000004  07c9              LSLS     r1,r1,#31
000006  0fc9              LSRS     r1,r1,#31
;;;318    {
000008  d01e              BEQ      |L10.72|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]
;;;319    	static uint16_t CNT = 0;
;;;320    //	static uint16_t counter_test = 0;
;;;321    
;;;322    	
;;;323        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;324        {
;;;325            TIMER_ClearIntFlag(TIMER3);
;;;326    
;;;327    		if (is_flag_set(flag_0_23Hz))
00000e  4910              LDR      r1,|L10.80|
000010  6888              LDR      r0,[r1,#8]  ; BitFlag
000012  0780              LSLS     r0,r0,#30
000014  d501              BPL      |L10.26|
;;;328    		{
;;;329    			counter_target = 4302; 
000016  480f              LDR      r0,|L10.84|
000018  e009              B        |L10.46|
                  |L10.26|
;;;330    		}
;;;331    		else if (is_flag_set(flag_1Hz))
00001a  6888              LDR      r0,[r1,#8]  ; BitFlag
00001c  0740              LSLS     r0,r0,#29
00001e  d502              BPL      |L10.38|
;;;332    		{
;;;333    			counter_target = 1000; 
000020  207d              MOVS     r0,#0x7d
000022  00c0              LSLS     r0,r0,#3
000024  e003              B        |L10.46|
                  |L10.38|
;;;334    		}
;;;335    		else if (is_flag_set(flag_151Hz))
000026  6888              LDR      r0,[r1,#8]  ; BitFlag
000028  0700              LSLS     r0,r0,#28
00002a  d501              BPL      |L10.48|
;;;336    		{
;;;337    			counter_target = 6; 
00002c  2006              MOVS     r0,#6
                  |L10.46|
00002e  8008              STRH     r0,[r1,#0]
                  |L10.48|
;;;338    		}
;;;339    	
;;;340    		if (CNT++ >= counter_target)
000030  8848              LDRH     r0,[r1,#2]  ; CNT
000032  1c42              ADDS     r2,r0,#1
000034  804a              STRH     r2,[r1,#2]
000036  880a              LDRH     r2,[r1,#0]  ; counter_target
000038  4290              CMP      r0,r2
00003a  d305              BCC      |L10.72|
;;;341    		{		
;;;342    			CNT = 0;
00003c  2000              MOVS     r0,#0
00003e  8048              STRH     r0,[r1,#2]
;;;343    			LED_TOGGLE; //PB14 ^= 1;
000040  4805              LDR      r0,|L10.88|
000042  6b81              LDR      r1,[r0,#0x38]
000044  43c9              MVNS     r1,r1
000046  6381              STR      r1,[r0,#0x38]
                  |L10.72|
;;;344    		}
;;;345    
;;;346    		#if 0
;;;347    		if (counter_test++ >= 10)
;;;348    		{		
;;;349    			counter_test = 0;
;;;350    
;;;351    
;;;352    			if (is_flag_set(flag_reverse))
;;;353    			{
;;;354    				g_au32Freq++;	
;;;355    			}
;;;356    			else
;;;357    			{
;;;358    				g_au32Freq--;
;;;359    			}
;;;360    
;;;361    			if (g_au32Freq == 1100)
;;;362    			{
;;;363    				set_flag(flag_reverse , DISABLE);				
;;;364    			}
;;;365    			else if (g_au32Freq == 0)
;;;366    			{
;;;367    				set_flag(flag_reverse , ENABLE);
;;;368    			}
;;;369    
;;;370    			PWM_ConfigOutputChannel(PWM0, PWM_CH, g_au32Freq, PWM_DUTY);
;;;371    			PDMA_TimerCapture_Start();
;;;372    
;;;373    		}	
;;;374    		#endif
;;;375    				
;;;376        }
;;;377    }
000048  4770              BX       lr
;;;378    
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      0x40051020
                  |L10.80|
                          DCD      ||.data||
                  |L10.84|
                          DCD      0x000010ce
                  |L10.88|
                          DCD      0x40004840

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  UART02_IRQHandler PROC
;;;427    
;;;428    void UART02_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;429    {
;;;430        uint8_t i;
;;;431        static uint16_t u16UART_RX_Buffer_Index = 0;
;;;432    
;;;433    	if ((UART_GET_INT_FLAG(UART0,UART_INTSTS_RDAINT_Msk)))
000002  4d21              LDR      r5,|L11.136|
000004  69e8              LDR      r0,[r5,#0x1c]
;;;434    	{
;;;435            /* UART receive data available flag */
;;;436            
;;;437            /* Record RDA interrupt trigger times */
;;;438            uart0Dev.RDA_Trigger_Cnt++;
000006  4c21              LDR      r4,|L11.140|
000008  05c0              LSLS     r0,r0,#23             ;433
00000a  1de7              ADDS     r7,r4,#7
00000c  2600              MOVS     r6,#0                 ;433
;;;439            
;;;440            /* Move the data from Rx FIFO to sw buffer (RAM). */
;;;441            /* Every time leave 1 byte data in FIFO for Rx timeout */
;;;442            for(i = 0 ; i < (FIFO_THRESHOLD - 1) ; i++)
;;;443            {
;;;444                uart0Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
00000e  4b20              LDR      r3,|L11.144|
000010  37f9              ADDS     r7,r7,#0xf9           ;438
000012  2800              CMP      r0,#0                 ;433
000014  da11              BGE      |L11.58|
000016  78b8              LDRB     r0,[r7,#2]            ;438  ; uart0Dev
000018  1c40              ADDS     r0,r0,#1              ;438
00001a  70b8              STRB     r0,[r7,#2]            ;438
00001c  2100              MOVS     r1,#0                 ;442
                  |L11.30|
00001e  6828              LDR      r0,[r5,#0]
000020  889a              LDRH     r2,[r3,#4]  ; u16UART_RX_Buffer_Index
000022  54a0              STRB     r0,[r4,r2]
000024  1c52              ADDS     r2,r2,#1
;;;445                u16UART_RX_Buffer_Index ++;
000026  b290              UXTH     r0,r2
000028  8098              STRH     r0,[r3,#4]
;;;446    
;;;447                if (u16UART_RX_Buffer_Index >= RX_BUFFER_SIZE) 
00002a  28ff              CMP      r0,#0xff
00002c  d900              BLS      |L11.48|
;;;448                    u16UART_RX_Buffer_Index = 0;
00002e  809e              STRH     r6,[r3,#4]
                  |L11.48|
000030  1c49              ADDS     r1,r1,#1
000032  b2c9              UXTB     r1,r1                 ;442
000034  2903              CMP      r1,#3                 ;442
000036  d3f2              BCC      |L11.30|
                  |L11.56|
;;;449            }	
;;;450    	}
;;;451        else if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RXTOINT_Msk)) 
;;;452        {
;;;453            /* When Rx timeout flag is set to 1, it means there is no data needs to be transmitted. */
;;;454    
;;;455            /* Record Timeout times */
;;;456            uart0Dev.RXTO_Trigger_Cnt++;
;;;457    
;;;458            /* Move the last data from Rx FIFO to sw buffer. */
;;;459            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;460            {
;;;461                uart0Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
;;;462                u16UART_RX_Buffer_Index ++;
;;;463            }
;;;464    
;;;465            /* Clear UART RX parameter */
;;;466            UART_DISABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;467    		uart0Dev.Length = u16UART_RX_Buffer_Index;
;;;468            u16UART_RX_Buffer_Index = 0;
;;;469    
;;;470    		#if 1
;;;471    		printf("UART RX : 0x%2X \r\n" , uart0Dev.RX_Buffer[0]);
;;;472    		
;;;473    		UART0_Process(uart0Dev.RX_Buffer[0]);
;;;474    		#else
;;;475    
;;;476    		printf("\r\nUART0 Rx Received Data : %s\r\n",uart0Dev.RX_Buffer);
;;;477    		printf("UART0 Rx Received Len : %d\r\n",uart0Dev.Length);	
;;;478    		printf("UART0 Rx RDA (Fifofull) interrupt times : %d\r\n",uart0Dev.RDA_Trigger_Cnt);
;;;479    		printf("UART0 Rx RXTO (Timeout) interrupt times : %d\r\n",uart0Dev.RXTO_Trigger_Cnt);
;;;480    		#endif
;;;481    
;;;482    		/* Reset UART interrupt parameter */
;;;483    		UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;484    		memset(&uart0Dev, 0x00, sizeof(UART_BUF_t));
;;;485    		
;;;486        }
;;;487    	
;;;488    }
000038  bdf8              POP      {r3-r7,pc}
                  |L11.58|
00003a  69e8              LDR      r0,[r5,#0x1c]         ;451
00003c  04c0              LSLS     r0,r0,#19             ;451
00003e  d5fb              BPL      |L11.56|
000040  78f8              LDRB     r0,[r7,#3]            ;456  ; uart0Dev
000042  1c40              ADDS     r0,r0,#1              ;456
000044  70f8              STRB     r0,[r7,#3]            ;456
000046  e004              B        |L11.82|
                  |L11.72|
000048  6829              LDR      r1,[r5,#0]            ;461
00004a  8898              LDRH     r0,[r3,#4]            ;461  ; u16UART_RX_Buffer_Index
00004c  5421              STRB     r1,[r4,r0]            ;461
00004e  1c40              ADDS     r0,r0,#1              ;461
000050  8098              STRH     r0,[r3,#4]            ;462
                  |L11.82|
000052  69a8              LDR      r0,[r5,#0x18]         ;459
000054  0440              LSLS     r0,r0,#17             ;459
000056  d5f7              BPL      |L11.72|
000058  6868              LDR      r0,[r5,#4]            ;466
00005a  2111              MOVS     r1,#0x11              ;466
00005c  4388              BICS     r0,r0,r1              ;466
00005e  6068              STR      r0,[r5,#4]            ;466
000060  8898              LDRH     r0,[r3,#4]            ;467  ; u16UART_RX_Buffer_Index
000062  8038              STRH     r0,[r7,#0]            ;467
000064  809e              STRH     r6,[r3,#4]            ;468
000066  7821              LDRB     r1,[r4,#0]            ;471  ; uart0Dev
000068  a00a              ADR      r0,|L11.148|
00006a  f7fffffe          BL       __2printf
00006e  7820              LDRB     r0,[r4,#0]            ;473  ; uart0Dev
000070  f7fffffe          BL       UART0_Process
000074  2111              MOVS     r1,#0x11              ;483
000076  4628              MOV      r0,r5                 ;483
000078  f7fffffe          BL       UART_EnableInt
00007c  21ff              MOVS     r1,#0xff              ;484
00007e  3105              ADDS     r1,#5                 ;484
000080  4802              LDR      r0,|L11.140|
000082  f7fffffe          BL       __aeabi_memclr
000086  bdf8              POP      {r3-r7,pc}
;;;489    
                          ENDP

                  |L11.136|
                          DCD      0x40070000
                  |L11.140|
                          DCD      ||.bss||
                  |L11.144|
                          DCD      ||.data||
                  |L11.148|
000094  55415254          DCB      "UART RX : 0x%2X \r\n",0
000098  20525820
00009c  3a203078
0000a0  25325820
0000a4  0d0a00  
0000a7  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;489    
;;;490    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;491    {
;;;492        SYS_ResetModule(UART0_RST);
000002  4820              LDR      r0,|L12.132|
000004  f7fffffe          BL       SYS_ResetModule
;;;493    
;;;494        /* Configure UART0 and set UART0 baud rate */
;;;495        UART_Open(UART0, 115200);
000008  4c1f              LDR      r4,|L12.136|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;496    
;;;497    	/* Set UART receive time-out */
;;;498    	UART_SetTimeoutCnt(UART0, RX_TIMEOUT_CNT);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;499    
;;;500    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;501        UART0->FIFO = ((UART0->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
00001c  68a0              LDR      r0,[r4,#8]
00001e  21f0              MOVS     r1,#0xf0
000020  4388              BICS     r0,r0,r1
000022  3010              ADDS     r0,r0,#0x10
000024  60a0              STR      r0,[r4,#8]
;;;502    
;;;503    	/* Enable UART Interrupt - */
;;;504    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
000026  6860              LDR      r0,[r4,#4]
000028  2111              MOVS     r1,#0x11
00002a  4308              ORRS     r0,r0,r1
00002c  6060              STR      r0,[r4,#4]
00002e  2001              MOVS     r0,#1
000030  4916              LDR      r1,|L12.140|
000032  0300              LSLS     r0,r0,#12
000034  6008              STR      r0,[r1,#0]
;;;505    	
;;;506    	NVIC_EnableIRQ(UART02_IRQn);	
;;;507    
;;;508    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000036  f7fffffe          BL       CLK_GetCPUFreq
00003a  4601              MOV      r1,r0
00003c  a014              ADR      r0,|L12.144|
00003e  f7fffffe          BL       __2printf
;;;509    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000042  f7fffffe          BL       CLK_GetHXTFreq
000046  4601              MOV      r1,r0
000048  a018              ADR      r0,|L12.172|
00004a  f7fffffe          BL       __2printf
;;;510    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00004e  f7fffffe          BL       CLK_GetLXTFreq
000052  4601              MOV      r1,r0
000054  a01b              ADR      r0,|L12.196|
000056  f7fffffe          BL       __2printf
;;;511    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00005a  f7fffffe          BL       CLK_GetPCLK0Freq
00005e  4601              MOV      r1,r0
000060  a01e              ADR      r0,|L12.220|
000062  f7fffffe          BL       __2printf
;;;512    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000066  f7fffffe          BL       CLK_GetPCLK1Freq
00006a  4601              MOV      r1,r0
00006c  a022              ADR      r0,|L12.248|
00006e  f7fffffe          BL       __2printf
                  |L12.114|
;;;513    
;;;514    	UART_WAIT_TX_EMPTY(UART0);
000072  69a0              LDR      r0,[r4,#0x18]
000074  00c0              LSLS     r0,r0,#3
000076  d5fc              BPL      |L12.114|
;;;515    	memset(&uart0Dev, 0x00, sizeof(UART_BUF_t));
000078  21ff              MOVS     r1,#0xff
00007a  3105              ADDS     r1,#5
00007c  4825              LDR      r0,|L12.276|
00007e  f7fffffe          BL       __aeabi_memclr
;;;516    	
;;;517    }
000082  bd10              POP      {r4,pc}
;;;518    
                          ENDP

                  |L12.132|
                          DCD      0x04000010
                  |L12.136|
                          DCD      0x40070000
                  |L12.140|
                          DCD      0xe000e100
                  |L12.144|
000090  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000094  4b5f4765
000098  74435055
00009c  46726571
0000a0  203a2025
0000a4  38640d0a
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L12.172|
0000ac  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000b0  47657448
0000b4  58544672
0000b8  6571203a
0000bc  20253864
0000c0  0d0a00  
0000c3  00                DCB      0
                  |L12.196|
0000c4  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c8  4765744c
0000cc  58544672
0000d0  6571203a
0000d4  20253864
0000d8  0d0a00  
0000db  00                DCB      0
                  |L12.220|
0000dc  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000e0  47657450
0000e4  434c4b30
0000e8  46726571
0000ec  203a2025
0000f0  38640d0a
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L12.248|
0000f8  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000fc  47657450
000100  434c4b31
000104  46726571
000108  203a2025
00010c  38640d0a
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L12.276|
                          DCD      ||.bss||

                          AREA ||i.UART0_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Process PROC
;;;386    
;;;387    void UART0_Process(uint8_t rx)
000000  b570              PUSH     {r4-r6,lr}
;;;388    {
;;;389    	switch(rx)
;;;390    	{
;;;391    		case 'a':
;;;392    		case 'A':
;;;393    			g_au32Freq = (g_au32Freq >= 24000000ul) ? (24000000ul) : (g_au32Freq + 100) ;	
000002  4c22              LDR      r4,|L13.140|
;;;394    			printf("Freq : %4d \r\n" , g_au32Freq);
;;;395    			PWM_ConfigOutputChannel(PWM0, PWM_CH, g_au32Freq, PWM_DUTY);
000004  4d20              LDR      r5,|L13.136|
000006  68e1              LDR      r1,[r4,#0xc]          ;389
000008  2844              CMP      r0,#0x44              ;389
00000a  d022              BEQ      |L13.82|
00000c  dc08              BGT      |L13.32|
00000e  2831              CMP      r0,#0x31              ;389
000010  d02f              BEQ      |L13.114|
000012  2832              CMP      r0,#0x32              ;389
000014  d030              BEQ      |L13.120|
000016  2833              CMP      r0,#0x33              ;389
000018  d031              BEQ      |L13.126|
00001a  2841              CMP      r0,#0x41              ;389
00001c  d128              BNE      |L13.112|
00001e  e010              B        |L13.66|
                  |L13.32|
000020  285a              CMP      r0,#0x5a              ;389
000022  d005              BEQ      |L13.48|
000024  2861              CMP      r0,#0x61              ;389
000026  d00c              BEQ      |L13.66|
000028  2864              CMP      r0,#0x64              ;389
00002a  d012              BEQ      |L13.82|
00002c  287a              CMP      r0,#0x7a              ;389
00002e  d11f              BNE      |L13.112|
                  |L13.48|
000030  f3bf8f4f          DSB                            ;389
000034  4917              LDR      r1,|L13.148|
000036  4816              LDR      r0,|L13.144|
000038  60c8              STR      r0,[r1,#0xc]          ;389
00003a  f3bf8f4f          DSB                            ;389
                  |L13.62|
00003e  bf00              NOP                            ;389
000040  e7fd              B        |L13.62|
                  |L13.66|
000042  4815              LDR      r0,|L13.152|
000044  4281              CMP      r1,r0                 ;393
000046  d201              BCS      |L13.76|
000048  4608              MOV      r0,r1                 ;393
00004a  3064              ADDS     r0,r0,#0x64           ;393
                  |L13.76|
00004c  4601              MOV      r1,r0                 ;393
;;;396    			PDMA_TimerCapture_Start();
;;;397    		break;
00004e  60e0              STR      r0,[r4,#0xc]  ; g_au32Freq
000050  e003              B        |L13.90|
                  |L13.82|
;;;398    
;;;399    		case 'd':
;;;400    		case 'D':
;;;401    			g_au32Freq = (g_au32Freq <= 0) ? (0) : (g_au32Freq - 1) ;	
000052  2900              CMP      r1,#0
000054  d000              BEQ      |L13.88|
000056  1e49              SUBS     r1,r1,#1
                  |L13.88|
000058  60e1              STR      r1,[r4,#0xc]  ; g_au32Freq
                  |L13.90|
;;;402    			printf("Freq : %4d \r\n" , g_au32Freq);
00005a  a010              ADR      r0,|L13.156|
00005c  f7fffffe          BL       __2printf
;;;403    			PWM_ConfigOutputChannel(PWM0, PWM_CH, g_au32Freq, PWM_DUTY);
000060  2332              MOVS     r3,#0x32
000062  2100              MOVS     r1,#0
000064  4628              MOV      r0,r5
000066  68e2              LDR      r2,[r4,#0xc]  ; g_au32Freq
000068  f7fffffe          BL       PWM_ConfigOutputChannel
;;;404    			PDMA_TimerCapture_Start();
00006c  f7fffffe          BL       PDMA_TimerCapture_Start
                  |L13.112|
;;;405    		break;	
;;;406    
;;;407    		case '1':				
;;;408    			set_flag(flag_0_23Hz , ENABLE);
;;;409    		break;
;;;410    
;;;411    		case '2':
;;;412    			set_flag(flag_1Hz , ENABLE);
;;;413    		break;
;;;414    
;;;415    		case '3':
;;;416    			set_flag(flag_151Hz , ENABLE);
;;;417    		break;			
;;;418    
;;;419    
;;;420    		case 'Z':
;;;421    		case 'z':
;;;422    			NVIC_SystemReset();
;;;423    		break;
;;;424    		
;;;425    	}
;;;426    }
000070  bd70              POP      {r4-r6,pc}
                  |L13.114|
000072  68a0              LDR      r0,[r4,#8]            ;408  ; BitFlag
000074  2102              MOVS     r1,#2                 ;408
000076  e004              B        |L13.130|
                  |L13.120|
000078  68a0              LDR      r0,[r4,#8]            ;412  ; BitFlag
00007a  2104              MOVS     r1,#4                 ;412
00007c  e001              B        |L13.130|
                  |L13.126|
00007e  68a0              LDR      r0,[r4,#8]            ;416  ; BitFlag
000080  2108              MOVS     r1,#8                 ;416
                  |L13.130|
000082  4308              ORRS     r0,r0,r1              ;416
000084  60a0              STR      r0,[r4,#8]            ;416  ; BitFlag
000086  bd70              POP      {r4-r6,pc}
;;;427    
                          ENDP

                  |L13.136|
                          DCD      0x40058000
                  |L13.140|
                          DCD      ||.data||
                  |L13.144|
                          DCD      0x05fa0004
                  |L13.148|
                          DCD      0xe000ed00
                  |L13.152|
                          DCD      0x016e3600
                  |L13.156|
00009c  46726571          DCB      "Freq : %4d \r\n",0
0000a0  203a2025
0000a4  3464200d
0000a8  0a00    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;583    
;;;584    int main()
000000  f7fffffe          BL       SYS_Init
;;;585    {
;;;586        SYS_Init();
;;;587    
;;;588        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;589    
;;;590    	GPIO_Init();		//PB14 : LED
000008  f7fffffe          BL       GPIO_Init
;;;591    	
;;;592    	TIMER3_Init();	
00000c  f7fffffe          BL       TIMER3_Init
;;;593    
;;;594        PWM0_Init();	//PB5 : PWM0_CH0
000010  f7fffffe          BL       PWM0_Init
;;;595    
;;;596    	PDMA_TimerCapture_Init();	//PA10 : TM1_EXT 
000014  f7fffffe          BL       PDMA_TimerCapture_Init
                  |L14.24|
;;;597    
;;;598        /* Got no where to go, just loop forever */
;;;599        while(1)
000018  e7fe              B        |L14.24|
;;;600        {
;;;601    
;;;602    
;;;603        }
;;;604    }
;;;605    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  uart0Dev
                          %        260

                          AREA ||.data||, DATA, ALIGN=2

                  counter_target
000000  03e8              DCW      0x03e8
                  ||CNT||
000002  0000              DCW      0x0000
                  u16UART_RX_Buffer_Index
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  BitFlag
                          DCD      0x00000000
                  g_au32Freq
                          DCD      0x00000064
                  g_au32CAPValue
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
